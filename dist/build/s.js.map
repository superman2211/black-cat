{
  "version": 3,
  "sources": ["../../src/utils/math.ts", "../../src/utils/browser.ts", "../../src/utils/pattern.ts", "../../src/utils/image.ts", "../../src/resources/images.ts", "../../src/utils/geom.ts", "../../src/utils/time.ts", "../../src/engine/animation.ts", "../../src/engine/effect.ts", "../../src/engine/stage.ts", "../../src/engine/unit.ts", "../../src/resources/font.ts", "../../src/engine/graphics.ts", "../../src/resources/sound/zzfx.js", "../../src/resources/sound/audio.ts", "../../src/engine/input.ts", "../../src/game/hero.ts", "../../src/resources/sfxr.ts", "../../src/resources/sounds.ts", "../../src/resources/loader.ts", "../../src/resources/background.ts", "../../src/game/stages/bar.ts", "../../src/game/start.ts", "../../src/game/game.ts", "../../src/game/mob.ts", "../../src/index.ts"],
  "sourcesContent": ["const math = Math;\n\nexport const mathFloor = math.floor;\nexport const mathCeil = math.ceil;\nexport const mathRound = math.round;\nexport const mathMin = math.min;\nexport const mathMax = math.max;\nexport const mathHypot = math.hypot;\nexport const mathAbs = math.abs;\nexport const mathRandom = math.random;\nexport const mathAtan2 = math.atan2;\nexport const mathPI = math.PI;\nexport const mathPI2 = mathPI * 2;\nexport const numberMax = Number.MAX_VALUE;\n\nexport const limit = (min: number, max: number, value: number) => mathMin(max, mathMax(min, value));\nexport const lerp = (min: number, max: number, value: number) => min + value * (max - min);\nexport const randomRange = (min: number, max: number): number => lerp(min, max, mathRandom());\nexport const chance = (chance: number): boolean => mathRandom() < chance;\n\nexport function randomSelect<T>(values: T[]): T {\n    return values[mathRound(randomRange(0, values.length - 1))];\n}\n\nexport function randomChancesSelect<T>(values: T[], chances: Array<number>): T {\n    const total = chances.reduce((p, c) => p + c, 0);\n\n    const chance = mathRandom() * total;\n    \n    let c = 0;\n\n    for(let i = 0; i < values.length; i++) {\n        c += chances[i];\n        if (chance < c) {\n            return values[i];\n        }\n    }\n\n    return values[0];\n}", "import { mathRound } from \"./math\";\n\nexport const domDocument = document;\nexport const hasTouch = 'ontouchstart' in window;\nexport const dpr = devicePixelRatio;\n\nconst canvasName = 'canvas';\n\nexport const getContext = (canvas: HTMLCanvasElement) => canvas.getContext('2d')!;\nexport const createCanvas = () => domDocument.createElement(canvasName);\nexport const createContext = () => getContext(createCanvas());\nexport const getCanvas = (context: CanvasRenderingContext2D) => context.canvas;\nexport const getWidth = (context: CanvasRenderingContext2D) => getCanvas(context).width;\nexport const getHeight = (context: CanvasRenderingContext2D) => getCanvas(context).height;\nexport const setWidth = (context: CanvasRenderingContext2D, width: number) => getCanvas(context).width = width;\nexport const setHeight = (context: CanvasRenderingContext2D, height: number) => getCanvas(context).height = height;\nexport const resetTransform = (context: CanvasRenderingContext2D) => context.resetTransform();\nexport const drawImage = (context: CanvasRenderingContext2D, image: HTMLCanvasElement, x: number, y: number) => context.drawImage(image, mathRound(x), mathRound(y));\nexport const clear = (context: CanvasRenderingContext2D) => { resetTransform(context); context.clearRect(0, 0, getWidth(context), getHeight(context)); }\n\nexport const now = () => performance.now();\n\nexport const cloneObject = (source: any): any => JSON.parse(JSON.stringify(source));\n\nexport async function timeout(time: number) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, time);\n    })\n}\n", "export const formatColor = (c: number): string => {\n    const a = c >> 24 & 0xff;\n    const r = c >> 16 & 0xff;\n    const g = c >> 8 & 0xff;\n    const b = c & 0xff;\n\n    return `rgba(${r}, ${g}, ${b}, ${a / 0xff})`;\n}\n\nexport const createGradient = (\n    context: CanvasRenderingContext2D,\n    x0: number, y0: number, x1: number, y1: number,\n    startColor: number, endColor: number\n) => {\n    const gradient = context.createLinearGradient(x0, y0, x1, y1);\n    gradient.addColorStop(0, formatColor(startColor));\n    gradient.addColorStop(1, formatColor(endColor));\n    return gradient;\n}", "import { images } from \"../resources/images\";\nimport { createCanvas, drawImage, getContext } from \"./browser\";\nimport { mathCeil, randomChancesSelect, randomSelect } from \"./math\";\nimport { createGradient } from \"./pattern\";\n\nexport const generateRandomTileImage = (width: number, height: number, ids: Array<number>, chances: Array<number>): HTMLCanvasElement => {\n    const canvas = createCanvas();\n    const context = getContext(canvas);\n\n    let image = images[ids[0]];\n\n    canvas.width = width;\n    canvas.height = height;\n\n    const sx = mathCeil(width / image.width);\n    const sy = mathCeil(height / image.height);\n\n    for (let x = 0; x < sx; x++) {\n        for (let y = 0; y < sy; y++) {\n            image = images[randomChancesSelect(ids, chances)];\n            context.drawImage(image, x * image.width, y * image.height);\n        }\n    }\n\n    return canvas;\n}\n\nexport const generateTileImage = (width: number, height: number, imageId: number): HTMLCanvasElement => {\n    const canvas = createCanvas();\n    const context = getContext(canvas);\n\n    canvas.width = width;\n    canvas.height = height;\n\n    const image = images[imageId];\n\n    const sx = mathCeil(width / image.width);\n    const sy = mathCeil(height / image.height);\n\n    for (let x = 0; x < sx; x++) {\n        for (let y = 0; y < sy; y++) {\n            context.drawImage(image, x * image.width, y * image.height);\n        }\n    }\n\n    return canvas;\n}\n\nexport const drawCommands = (commands: Array<number>, context: CanvasRenderingContext2D) => {\n    for (let i = 0; i < commands.length; i += 3) {\n        const id = commands[i];\n        const x = commands[i + 1];\n        const y = commands[i + 2];\n        const image = images[id];\n        drawImage(context, image, x, y);\n    }\n}\n\nexport const drawGradientV = (context: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, startColor: number, endColor: number) => {\n    context.fillStyle = createGradient(context, x, y, x, y + height, startColor, endColor);\n    context.fillRect(x, y, width, height);\n}\n\nexport const drawGradientH = (context: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, startColor: number, endColor: number) => {\n    context.fillStyle = createGradient(context, x, y, x + width, y, startColor, endColor);\n    context.fillRect(x, y, width, height);\n}\n\nexport const filterImage = (canvas: HTMLCanvasElement, filter: (color: Uint8ClampedArray) => void) => {\n    const context = getContext(canvas);\n    const width = canvas.width;\n    const height = canvas.height;\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = imageData.data;\n\n    let i = 0;\n\n    while (i < pixels.length) {\n        const pixel = pixels.slice(i, i + 4);\n\n        filter(pixel);\n\n        pixels.set(pixel, i);\n\n        i += 4;\n    }\n\n    context.putImageData(imageData, 0, 0);\n}\n\nexport const cloneCanvas = (source: HTMLCanvasElement): HTMLCanvasElement => {\n    var target = createCanvas();\n    var context = getContext(target);\n    target.width = source.width;\n    target.height = source.height;\n    context.drawImage(source, 0, 0);\n    return target;\n}\n\nexport const getPallette = (canvas: HTMLCanvasElement): Array<number> => {\n    const pallette: Array<number> = [];\n\n    filterImage(canvas, (pixel) => {\n        const color = pixelToColor(pixel);\n        if (pallette.indexOf(color) == -1) {\n            pallette.push(color);\n        }\n    });\n\n    return pallette;\n}\n\nexport const applyPallette = (canvas: HTMLCanvasElement, sourcePallette: Array<number>, targetPallette: Array<number>) => {\n    filterImage(canvas, (pixel) => {\n        const sourceColor = pixelToColor(pixel);\n\n        const index = sourcePallette.indexOf(sourceColor);\n\n        if (index != -1) {\n            const targetColor = targetPallette[index];\n\n            colorToPixel(targetColor, pixel);\n        }\n    });\n}\n\nconst u32 = new Uint32Array(1);\n\nexport const pixelToColor = (pixel: Uint8ClampedArray): number => {\n    const r = pixel[0];\n    const g = pixel[1];\n    const b = pixel[2];\n    const a = pixel[3];\n\n    u32[0] = (a << 24) | (r << 16) | (g << 8) | b;\n\n    return u32[0];\n}\n\nexport const colorToPixel = (color: number, pixel: Uint8ClampedArray) => {\n    const a = (color >> 24) & 0xff;\n    const r = (color >> 16) & 0xff;\n    const g = (color >> 8) & 0xff;\n    const b = color & 0xff;\n\n    pixel[0] = r;\n    pixel[1] = g;\n    pixel[2] = b;\n    pixel[3] = a;\n}", "import { createCanvas } from \"../utils/browser\";\nimport { cloneCanvas, filterImage } from \"../utils/image\";\n\nexport const images: HTMLCanvasElement[] = [];\n\nconst coloredImages: { [key: string]: number } = {};\n\nexport const addImage = (image: HTMLCanvasElement): number => {\n    const id = images.length;\n    images.push(image);\n    return id;\n}\n\nexport const getColoredImage = (id: number, color: number): number => {\n    const key = `${id}_${color}`;\n    if (!coloredImages[key]) {\n        const a = (color >> 24) & 0xff;\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n\n        const coloredImage = cloneCanvas(images[id]);\n\n        filterImage(coloredImage, (color) => {\n            color[0] = r;\n            color[1] = g;\n            color[2] = b;\n            if (color[3]) {\n                color[3] = a;\n            }\n        });\n\n        coloredImages[key] = addImage(coloredImage);\n    }\n\n    return coloredImages[key];\n}\n", "import { mathHypot } from \"./math\"\n\nexport interface Vector2 {\n    x: number,\n    y: number,\n}\n\nexport interface Box2 {\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n}\n\nexport interface Transform {\n    a: number,\n    b: number,\n    c: number,\n    d: number,\n    tx: number,\n    ty: number,\n}\n\nexport namespace Vector2 {\n    export const normalize = (a: Vector2) => {\n        const l = length(a);\n        if (l > 0) {\n            a.x /= l;\n            a.y /= l;\n        }\n    }\n\n    export const length = (a: Vector2): number => {\n        return mathHypot(a.x, a.y);\n    }\n\n    export const distance = (a: Vector2, b: Vector2): number => {\n        return mathHypot(a.x - b.x, a.y - b.y);\n    }\n\n    export const add = (a: Vector2, b: Vector2): Vector2 => {\n        return { x: a.x + b.x, y: a.y + b.y };\n    }\n\n    export const subtract = (a: Vector2, b: Vector2): Vector2 => {\n        return { x: a.x - b.x, y: a.y - b.y };\n    }\n\n    export const scale = (a: Vector2, s: number): Vector2 => {\n        return { x: a.x * s, y: a.y * s };\n    }\n}", "import { now } from \"./browser\";\n\nexport let nowMS: number = now();\nexport let deltaS: number = 0;\n\nexport const calculateTime = () => {\n    const oldMS = nowMS;\n    nowMS = now();\n    deltaS = (nowMS - oldMS) / 1000;\n}", "export interface AnimationFrame {\n    image: number,\n    time: number,\n}\n\nexport const animationDuration = (animation: Array<AnimationFrame>): number => {\n    let time = 0;\n\n    for (const frame of animation) {\n        time += frame.time;\n    }\n\n    return time;\n}\n\nexport const getFrameImage = (animation: Array<AnimationFrame>, animationTime: number): number => {\n    let time = 0;\n\n    const duratuion = animationDuration(animation);\n    animationTime %= duratuion;\n\n    for (let i = 0; i < animation.length; i++) {\n        const frame = animation[i];\n        time += frame.time;\n\n        if (animationTime <= time) {\n            return frame.image;\n        }\n    }\n\n    return 0;\n}\n\nexport const isAnimationFinished = (animation: Array<AnimationFrame>, animationTime: number): boolean => {\n    const duratuion = animationDuration(animation);\n    return animationTime >= duratuion;\n}\n", "import { hit0, hit1, hit2, hitMini0, hitMini1, hitMini2, hitRed0, hitRed1, hitRed2 } from \"../resources/id\";\nimport { Vector2 } from \"../utils/geom\";\nimport { deltaS } from \"../utils/time\";\nimport { animationDuration, AnimationFrame, getFrameImage } from \"./animation\";\nimport { Sprite } from \"./sprite\";\n\nexport const effects: Array<Effect> = [];\n\nexport interface Effect {\n    sprite: Sprite,\n    animation: Array<AnimationFrame>,\n    animationTime: number,\n}\n\nexport interface EffectConfig {\n    animation: Array<AnimationFrame>,\n    offset: Vector2,\n}\n\nexport const hitEffect: EffectConfig = {\n    animation: [\n        { image: hit0, time: 0.1 },\n        { image: hit1, time: 0.1 },\n        { image: hit2, time: 0.1 },\n    ],\n    offset: { x: 16, y: 16 }\n}\n\nexport const hitMiniEffect: EffectConfig = {\n    animation: [\n        { image: hitMini0, time: 0.1 },\n        { image: hitMini1, time: 0.2 },\n        { image: hitMini2, time: 0.2 },\n    ],\n    offset: { x: 8, y: 8 }\n}\n\nexport const hitRedEffect: EffectConfig = {\n    animation: [\n        { image: hitRed0, time: 0.1 },\n        { image: hitRed1, time: 0.2 },\n        { image: hitRed2, time: 0.2 },\n    ],\n    offset: { x: 8, y: 8 }\n}\n\nexport const removeEffect = (effect: Effect) => {\n    const index = effects.indexOf(effect);\n    if (index != -1) {\n        effects.splice(index, 1);\n    }\n}\n\nexport const addEffect = (config: EffectConfig, position: Vector2) => {\n    effects.push({\n        animation: config.animation,\n        animationTime: 0,\n        sprite: {\n            image: 0,\n            x: position.x - config.offset.x,\n            y: position.y - config.offset.y\n        }\n    });\n}\n\nexport const updateEffects = () => {\n    for (const effect of effects) {\n        const duration = animationDuration(effect.animation);\n        effect.animationTime += deltaS;\n        if (effect.animationTime > duration) {\n            removeEffect(effect);\n        } else {\n            effect.sprite.image = getFrameImage(effect.animation, effect.animationTime);\n        }\n    }\n}", "import { images } from \"../resources/images\";\nimport { Box2, Vector2 } from \"../utils/geom\";\nimport { gameHeight, gameWidth } from \"./graphics\";\nimport { Sprite } from \"./sprite\";\n\nexport interface Stage {\n    bounds: Box2,\n    back: Sprite,\n    camera: Vector2,\n}\n\nlet stage: Stage | undefined;\n\nexport const getStage = () => stage!;\n\nexport const setStage = (value: Stage) => stage = value;\n\nexport const limitCamera = () => {\n    const stage = getStage();\n    const back = images[stage.back.image];\n\n    if (- stage.camera.x > 0) {\n        stage.camera.x = 0;\n    }\n\n    if (-stage.camera.x + back.width < gameWidth) {\n        stage.camera.x = back.width - gameWidth;\n    }\n\n    if (- stage.camera.y > 0) {\n        stage.camera.y = 0;\n    }\n\n    if (-stage.camera.y + back.height < gameHeight) {\n        stage.camera.y = back.height - gameHeight;\n    }\n}", "import { getColoredImage, images } from \"../resources/images\";\nimport { Vector2 } from \"../utils/geom\";\nimport { chance, limit, mathAbs, mathHypot, mathRound, numberMax, randomChancesSelect, randomRange, randomSelect } from \"../utils/math\";\nimport { deltaS } from \"../utils/time\";\nimport { animationDuration, AnimationFrame, getFrameImage, isAnimationFinished } from \"./animation\";\nimport { addEffect, hitEffect, hitMiniEffect, hitRedEffect } from \"./effect\";\nimport { Sprite } from \"./sprite\";\nimport { getStage } from \"./stage\";\n\nexport const units: Array<Unit> = [];\n\nexport const enum UnitState {\n    Stand,\n    Walk,\n    Jab,\n    Cross,\n    Kick,\n    Damage,\n    Dead,\n}\n\nexport interface Unit {\n    config: UnitConfig,\n    state: UnitState,\n    controller: {\n        move: Vector2,\n        hand: boolean,\n        cross: boolean,\n        leg: boolean,\n    },\n    health: number,\n    direction: number,\n    position: Vector2,\n    speed: Vector2,\n    animationTime: number,\n    animation?: Array<AnimationFrame>,\n    sprite: Sprite,\n    shadow: Sprite,\n    frame: number,\n    damage: number,\n}\n\nexport interface UnitConfig {\n    mob: boolean,\n    health: number,\n    walkSpeed: number,\n    offset: Vector2,\n    animations: {\n        stand: Array<AnimationFrame>,\n        walkH: Array<AnimationFrame>,\n        walkV: Array<AnimationFrame>,\n        jab: Array<AnimationFrame>,\n        cross: Array<AnimationFrame>,\n        kick: Array<AnimationFrame>,\n        damage1: Array<AnimationFrame>,\n        damage2: Array<AnimationFrame>,\n        knockdown: Array<AnimationFrame>,\n        dead1: Array<AnimationFrame>,\n        dead2: Array<AnimationFrame>,\n    },\n    damages: { [key: number]: number },\n}\n\nexport const addUnit = (config: UnitConfig): Unit => {\n    let unit: Unit = {\n        config,\n        state: UnitState.Stand,\n        controller: {\n            move: {\n                x: 0,\n                y: 0\n            },\n            hand: false,\n            leg: false,\n            cross: false\n        },\n        health: config.health,\n        direction: 1,\n        position: {\n            x: 0,\n            y: 0\n        },\n        speed: {\n            x: 0,\n            y: 0\n        },\n        animationTime: 0,\n        sprite: {\n            image: 0,\n        },\n        shadow: {\n            image: 0,\n        },\n        damage: 0,\n        frame: 0,\n    };\n\n    units.push(unit);\n\n    return unit;\n}\n\nexport const removeUnit = (unit: Unit) => {\n    const index = units.indexOf(unit);\n    if (index != -1) {\n        units.splice(index, 1);\n    }\n}\n\nexport const clearUnits = () => {\n    units.splice(0, units.length);\n}\n\nexport const limitUnitsPositions = () => {\n    const stage = getStage();\n\n    for (const unit of units.values()) {\n        unit.position.x = limit(stage.bounds.x, stage.bounds.x + stage.bounds.w, unit.position.x);\n        unit.position.y = limit(stage.bounds.y, stage.bounds.y + stage.bounds.h, unit.position.y);\n    }\n}\n\nexport const updateUnits = () => {\n    for (const unit of units.values()) {\n        updateUnit(unit);\n    }\n}\n\nconst updateUnit = (unit: Unit) => {\n    let currentAnimation = null;\n\n    const config = unit.config;\n    const animations = config.animations;\n\n    switch (unit.state) {\n        case UnitState.Stand:\n            currentAnimation = animations.stand;\n\n            if (unit.controller.move.x != 0 || unit.controller.move.y != 0) {\n                unit.state = UnitState.Walk;\n                unit.animationTime = 0;\n            }\n\n            checkAttack(unit);\n            break;\n\n        case UnitState.Walk:\n            if (unit.controller.move.x == 0 && unit.controller.move.y == 0) {\n                unit.state = UnitState.Stand;\n                unit.animationTime = 0;\n            }\n            else if (mathAbs(unit.controller.move.x) > mathAbs(unit.controller.move.y)) {\n                currentAnimation = animations.walkH;\n            } else {\n                currentAnimation = animations.walkV;\n            }\n\n            Vector2.normalize(unit.controller.move);\n\n            unit.position.x += unit.controller.move.x * config.walkSpeed * deltaS;\n            unit.position.y += unit.controller.move.y * config.walkSpeed * deltaS;\n\n            checkAttack(unit);\n            break;\n\n        case UnitState.Jab:\n            currentAnimation = animations.jab;\n\n            if (isAnimationFinished(currentAnimation, unit.animationTime)) {\n                if (unit.controller.hand) {\n                    unit.state = UnitState.Cross;\n                } else {\n                    unit.state = UnitState.Stand;\n                }\n                unit.animationTime = 0;\n            }\n            break;\n\n        case UnitState.Cross:\n            currentAnimation = animations.cross;\n\n            if (isAnimationFinished(currentAnimation, unit.animationTime)) {\n                if (!unit.controller.hand) {\n                    unit.state = UnitState.Stand;\n                    unit.animationTime = 0;\n                }\n            }\n            break;\n\n        case UnitState.Kick:\n            currentAnimation = animations.kick;\n\n            if (isAnimationFinished(currentAnimation, unit.animationTime)) {\n                unit.state = UnitState.Stand;\n                unit.animationTime = 0;\n            }\n            break;\n\n        case UnitState.Damage:\n            currentAnimation = unit.animation || animations.damage1;\n\n            if (isAnimationFinished(currentAnimation, unit.animationTime)) {\n                unit.state = UnitState.Stand;\n                unit.animationTime = 0;\n                unit.animation = undefined;\n            }\n            break;\n\n        case UnitState.Dead:\n            currentAnimation = unit.animation || animations.dead1;\n\n            const duration = animationDuration(currentAnimation);\n            if (duration <= unit.animationTime + deltaS) {\n                removeUnit(unit);\n                currentAnimation = null;\n            }\n            break;\n    }\n\n    unit.position.x += unit.speed.x * deltaS;\n    unit.position.y += unit.speed.y * deltaS;\n\n    unit.speed.x *= 0.9;\n    unit.speed.y *= 0.9;\n\n    if (unit.controller.move.x > 0) {\n        unit.direction = 1;\n    } else if (unit.controller.move.x < 0) {\n        unit.direction = -1;\n    }\n\n    if (currentAnimation) {\n        unit.animationTime += deltaS;\n\n        unit.sprite.image = getFrameImage(currentAnimation, unit.animationTime);\n        unit.sprite.flipX = unit.direction < 0;\n\n        unit.shadow.image = getColoredImage(unit.sprite.image, 0x55000000);\n        unit.shadow.flipX = unit.sprite.flipX;\n    }\n\n    unit.damage = 0;\n    if (unit.frame != unit.sprite.image) {\n        unit.frame = unit.sprite.image;\n        unit.damage = config.damages[unit.frame] || 0;\n    }\n}\n\nexport const applyUnitsDamage = () => {\n    for (const current of units) {\n        if (current.health <= 0) {\n            continue;\n        }\n\n        if (!current.damage) {\n            continue;\n        }\n\n        let opponent: Unit | null = null;\n        let opponentDistanceX = numberMax;\n        let opponentDistanceY = numberMax;\n\n        for (const unit of units) {\n            if (unit.health <= 0) {\n                continue;\n            }\n\n            if (current.config.mob != unit.config.mob) {\n                const directionX = unit.position.x - current.position.x;\n                if (directionX * current.direction > 0) {\n                    const distanceX = mathAbs(directionX);\n                    const distanceY = mathAbs(current.position.y - unit.position.y);\n                    if (distanceX < 25 && distanceY < 10) {\n                        if (!opponent || opponentDistanceX > distanceX || opponentDistanceY > distanceY) {\n                            opponent = unit;\n                            opponentDistanceX = distanceX;\n                            opponentDistanceY = distanceY;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (opponent) {\n            opponent.health -= current.damage;\n\n            opponent.speed.x += current.direction * current.damage / 100 * 300;\n            current.speed.x += current.direction * 10;\n\n            const effect = (() => {\n                if (current.damage >= 20) {\n                    return hitEffect;\n                } else {\n                    if (chance(0.5)) {\n                        return hitRedEffect;\n                    } else {\n                        return hitMiniEffect;\n                    }\n                }\n            })();\n\n            addEffect(effect, Vector2.add(opponent.position, { x: randomRange(-3, 3), y: randomRange(-14, -18) }));\n\n            if (opponent.health > 0) {\n                opponent.state = UnitState.Damage;\n\n                if (opponent.animation != opponent.config.animations.knockdown) {\n                    opponent.animationTime = 0;\n                }\n\n                opponent.animation = randomSelect([\n                    opponent.config.animations.damage1,\n                    opponent.config.animations.damage2,\n                    opponent.config.animations.knockdown,\n                ]);\n            } else {\n                opponent.state = UnitState.Dead;\n                opponent.animation = randomSelect([opponent.config.animations.dead1, opponent.config.animations.dead2]);\n                opponent.animationTime = 0;\n            }\n        }\n    }\n}\n\nexport const updateUnitsSpritePositions = () => {\n    for (const unit of units.values()) {\n        updateUnitSpritePosition(unit);\n    }\n}\n\nconst updateUnitSpritePosition = (unit: Unit) => {\n    const config = unit.config;\n\n    unit.sprite.x = unit.position.x - config.offset.x;\n    unit.sprite.y = unit.position.y - config.offset.y;\n\n    const image = images[unit.shadow.image];\n\n    unit.shadow.scaleY = 0.4;\n    unit.shadow.x = unit.position.x - config.offset.x + 0;\n    unit.shadow.y = unit.position.y - config.offset.y * unit.shadow.scaleY;\n}\n\nconst checkAttack = (unit: Unit) => {\n    if (unit.controller.leg) {\n        unit.state = UnitState.Kick;\n        unit.animationTime = 0;\n    }\n\n    if (unit.controller.hand) {\n        unit.state = UnitState.Jab;\n        unit.animationTime = 0;\n    }\n\n    if (unit.controller.cross) {\n        unit.state = UnitState.Cross;\n        unit.animationTime = 0;\n    }\n}", "import { DEBUG } from \"../debug\";\nimport { font0, font1, font10, font11, font12, font13, font14, font15, font16, font17, font18, font19, font2, font20, font21, font22, font23, font24, font25, font26, font27, font28, font29, font3, font30, font31, font32, font33, font34, font35, font36, font37, font4, font5, font6, font7, font8, font9 } from \"./id\";\n\nconst getChars = (): number[] => {\n    const chars: number[] = [];\n\n    chars[33] = font36;\n    chars[35] = 0;\n    chars[46] = font37;\n    chars[47] = -1;\n\n    chars.push(\n        font0,\n        font1,\n        font2,\n        font3,\n        font4,\n        font5,\n        font6,\n        font7,\n        font8,\n        font9,\n    );\n\n    chars[64] = 0;\n\n    chars.push(\n        font10,\n        font11,\n        font12,\n        font13,\n        font14,\n        font15,\n        font16,\n        font17,\n        font18,\n        font19,\n        font20,\n        font21,\n        font22,\n        font23,\n        font24,\n        font25,\n        font26,\n        font27,\n        font28,\n        font29,\n        font30,\n        font31,\n        font32,\n        font33,\n        font34,\n        font35,\n    );\n\n    return chars;\n}\n\nconst font = getChars();\n\nexport const getIdByCharCode = (code: number): number | undefined => {\n    if (DEBUG) {\n        if (code != 32 && (font[code] === undefined || font[code] === -1)) {\n            throw `symbol not found ${code} char ${String.fromCharCode(code)}`;\n        }\n    }\n\n    return font[code];\n}", "import { DEBUG } from \"../debug\";\nimport { units } from \"./unit\";\nimport { getIdByCharCode } from \"../resources/font\";\nimport { getColoredImage, images } from \"../resources/images\";\nimport { drawImage, getContext, now } from \"../utils/browser\";\nimport { mathFloor, mathMax, mathMin, mathRound } from \"../utils/math\";\nimport { deltaS, nowMS } from \"../utils/time\";\nimport { getStage } from \"./stage\";\nimport { Sprite } from \"./sprite\";\nimport { drawGradientH, drawGradientV } from \"../utils/image\";\nimport { effects } from \"./effect\";\n\nexport const canvas = document.getElementById('c') as HTMLCanvasElement;\ncanvas.style.imageRendering = 'pixelated';\n\nconst context = getContext(canvas);\n\nexport const gameWidth = 200;\nexport const gameHeight = 200;\n\nconst offset = { x: 0, y: 0 };\n\nexport const updateSize = () => {\n    const screenWidth = window.innerWidth;\n    const screenHeight = window.innerHeight;\n\n    const scale = mathMin(screenWidth / gameWidth, screenHeight / gameHeight);\n\n    canvas.width = mathMax(gameWidth, screenWidth / scale);\n    canvas.height = mathMax(gameHeight, screenHeight / scale);\n\n    canvas.style.width = `${screenWidth}px`;\n    canvas.style.height = `${screenHeight}px`;\n\n    offset.x = mathFloor((canvas.width - gameWidth) / 2);\n    offset.y = mathFloor((canvas.height - gameHeight) / 2);\n}\n\nexport const draw = () => {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.setTransform(1, 0, 0, 1, offset.x, offset.y);\n\n    const stage = getStage();\n\n    context.save();\n    context.translate(mathRound(-stage.camera.x), mathRound(-stage.camera.y));\n\n    drawSprite(stage.back);\n\n    units.sort((a, b) => a.position.y - b.position.y);\n\n    context.shadowBlur = 2;\n    context.shadowColor = \"black\";\n    for (const unit of units) {\n        drawSprite(unit.shadow);\n    }\n    context.shadowBlur = 0;\n\n    for (const unit of units) {\n        drawSprite(unit.sprite);\n    }\n\n    for (const effect of effects) {\n        drawSprite(effect.sprite);\n    }\n\n    context.restore();\n\n    context.fillStyle = \"black\";\n    if (canvas.width < canvas.height) {\n        context.fillRect(0, - offset.y, gameWidth, offset.y);\n        context.fillRect(0, gameHeight, gameWidth, gameHeight);\n    } else {\n        context.fillRect(- offset.x, 0, offset.x, gameWidth);\n        context.fillRect(gameWidth, 0, gameWidth, gameHeight);\n    }\n\n    drawFPS();\n\n    // drawText(\n    //     65, 0,\n    //     'BLACK KATE',\n    //     0xffffff\n    // );\n}\n\nconst drawSprite = (\n    sprite: Sprite\n) => {\n    context.save();\n\n    const image = images[sprite.image];\n\n    let a = 1;\n    let b = 0;\n    let c = 0;\n    let d = sprite.scaleY || 1;\n\n    let tx = mathRound(sprite.x || 0);\n    let ty = mathRound(sprite.y || 0);\n\n    if (sprite.flipX) {\n        a = -1;\n        tx += image.width;\n    }\n\n    context.transform(a, b, c, d, tx, ty);\n\n    drawImage(context, image, 0, 0);\n\n    context.restore();\n}\n\nconst drawFPS = () => {\n    if (DEBUG) {\n        const frameTime = (now() - nowMS).toFixed();\n        const fps = (1 / deltaS).toFixed();\n\n        drawText(\n            3, 3,\n            `FPS ${fps} TIME ${frameTime}`,\n            0x99ffffff\n        );\n    }\n}\n\nconst drawText = (x: number, y: number, text: string, color: number) => {\n    for (let i = 0; i < text.length; i++) {\n        const code = text[i].toUpperCase().charCodeAt(0);\n        const id = getIdByCharCode(code);\n        if (id !== undefined) {\n            const char = getColoredImage(id, color);\n            let image = images[char];\n            if (image !== undefined) {\n                drawImage(context, image, x + i * 8, y);\n            }\n        }\n    }\n}", "// zzfx() - the universal entry point -- returns a AudioBufferSourceNode\nconst zzfx = (...t) => zzfxP(zzfxG(...t))\n\n// zzfxP() - the sound player -- returns a AudioBufferSourceNode\nconst zzfxP = (...t) => { let e = zzfxX.createBufferSource(), f = zzfxX.createBuffer(t.length, t[0].length, zzfxR); t.map((d, i) => f.getChannelData(i).set(d)), e.buffer = f, e.connect(zzfxX.destination), e.start(); return e }\n\n// zzfxG() - the sound generator -- returns an array of sample data\nconst zzfxG = (q = 1, k = .05, c = 220, e = 0, t = 0, u = .1, r = 0, F = 1, v = 0, z = 0, w = 0, A = 0, l = 0, B = 0, x = 0, G = 0, d = 0, y = 1, m = 0, C = 0) => { let b = 2 * Math.PI, H = v *= 500 * b / zzfxR ** 2, I = (0 < x ? 1 : -1) * b / 4, D = c *= (1 + 2 * k * Math.random() - k) * b / zzfxR, Z = [], g = 0, E = 0, a = 0, n = 1, J = 0, K = 0, f = 0, p, h; e = 99 + zzfxR * e; m *= zzfxR; t *= zzfxR; u *= zzfxR; d *= zzfxR; z *= 500 * b / zzfxR ** 3; x *= b / zzfxR; w *= b / zzfxR; A *= zzfxR; l = zzfxR * l | 0; for (h = e + m + t + u + d | 0; a < h; Z[a++] = f)++K % (100 * G | 0) || (f = r ? 1 < r ? 2 < r ? 3 < r ? Math.sin((g % b) ** 3) : Math.max(Math.min(Math.tan(g), 1), -1) : 1 - (2 * g / b % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(g / b) - g / b) : Math.sin(g), f = (l ? 1 - C + C * Math.sin(2 * Math.PI * a / l) : 1) * (0 < f ? 1 : -1) * Math.abs(f) ** F * q * zzfxV * (a < e ? a / e : a < e + m ? 1 - (a - e) / m * (1 - y) : a < e + m + t ? y : a < h - d ? (h - a - d) / u * y : 0), f = d ? f / 2 + (d > a ? 0 : (a < h - d ? 1 : (h - a) / d) * Z[a - d | 0] / 2) : f), p = (c += v += z) * Math.sin(E * x - I), g += p - p * B * (1 - 1E9 * (Math.sin(a) + 1) % 2), E += p - p * B * (1 - 1E9 * (Math.sin(a) ** 2 + 1) % 2), n && ++n > A && (c += w, D += w, n = 0), !l || ++J % l || (c = D, v = H, n = n || 1); return Z }\n\n// zzfxV - global volume\nconst zzfxV = .3\n\n// zzfxR - global sample rate\nconst zzfxR = 44100\n\n// zzfxX - the common audio context\nconst zzfxX = new (window.AudioContext || webkitAudioContext);\n\n/**\n * ZzFX Music Renderer v2.0.3 by Keith Clark and Frank Force\n */\nconst zzfxM = (instruments, patterns, sequence, BPM = 125) => {\n    let instrumentParameters;\n    let i;\n    let j;\n    let k;\n    let note;\n    let sample;\n    let patternChannel;\n    let notFirstBeat;\n    let stop;\n    let instrument;\n    let pitch;\n    let attenuation;\n    let outSampleOffset;\n    let isSequenceEnd;\n    let sampleOffset = 0;\n    let nextSampleOffset;\n    let sampleBuffer = [];\n    let leftChannelBuffer = [];\n    let rightChannelBuffer = [];\n    let channelIndex = 0;\n    let panning = 0;\n    let hasMore = 1;\n    let sampleCache = {};\n    let beatLength = zzfxR / BPM * 60 >> 2;\n\n    // for each channel in order until there are no more\n    for (; hasMore; channelIndex++) {\n\n        // reset current values\n        sampleBuffer = [hasMore = notFirstBeat = pitch = outSampleOffset = 0];\n\n        // for each pattern in sequence\n        sequence.map((patternIndex, sequenceIndex) => {\n            // get pattern for current channel, use empty 1 note pattern if none found\n            patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];\n\n            // check if there are more channels\n            hasMore |= !!patterns[patternIndex][channelIndex];\n\n            // get next offset, use the length of first channel\n            nextSampleOffset = outSampleOffset + (patterns[patternIndex][0].length - 2 - !notFirstBeat) * beatLength;\n            // for each beat in pattern, plus one extra if end of sequence\n            isSequenceEnd = sequenceIndex == sequence.length - 1;\n            for (i = 2, k = outSampleOffset; i < patternChannel.length + isSequenceEnd; notFirstBeat = ++i) {\n\n                // <channel-note>\n                note = patternChannel[i];\n\n                // stop if end, different instrument or new note\n                stop = i == patternChannel.length + isSequenceEnd - 1 && isSequenceEnd ||\n                    instrument != (patternChannel[0] || 0) | note | 0;\n\n                // fill buffer with samples for previous beat, most cpu intensive part\n                for (j = 0; j < beatLength && notFirstBeat;\n\n                    // fade off attenuation at end of beat if stopping note, prevents clicking\n                    j++ > beatLength - 99 && stop ? attenuation += (attenuation < 1) / 99 : 0\n                ) {\n                    // copy sample to stereo buffers with panning\n                    sample = (1 - attenuation) * sampleBuffer[sampleOffset++] / 2 || 0;\n                    leftChannelBuffer[k] = (leftChannelBuffer[k] || 0) - sample * panning + sample;\n                    rightChannelBuffer[k] = (rightChannelBuffer[k++] || 0) + sample * panning + sample;\n                }\n\n                // set up for next note\n                if (note) {\n                    // set attenuation\n                    attenuation = note % 1;\n                    panning = patternChannel[1] || 0;\n                    if (note |= 0) {\n                        // get cached sample\n                        sampleBuffer = sampleCache[\n                            [\n                                instrument = patternChannel[sampleOffset = 0] || 0,\n                                note\n                            ]\n                        ] = sampleCache[[instrument, note]] || (\n                            // add sample to cache\n                            instrumentParameters = [...instruments[instrument]],\n                            // instrumentParameters[2] *= 2 ** ((note - 12) / 12),\n                            instrumentParameters[2] = (instrumentParameters[2] || 220) * (2 ** ((note - 12) / 12)),\n\n                            // allow negative values to stop notes\n                            note > 0 ? zzfxG(...instrumentParameters) : []\n                        );\n                    }\n                }\n            }\n\n            // update the sample offset\n            outSampleOffset = nextSampleOffset;\n        });\n    }\n\n    return [leftChannelBuffer, rightChannelBuffer];\n}\n\nexport { zzfx, zzfxG, zzfxP, zzfxR, zzfxV, zzfxX, zzfxM }", "import { timeout } from \"../../utils/browser\";\nimport { zzfxX as audioContext, zzfxM, zzfxP, zzfxX } from \"./zzfx\";\n\nconst unlockAudio = (force = false) => {\n  if (force || audioContext.state === \"suspended\") {\n    audioContext.resume().catch();\n  }\n};\n\nconst playMusic = async (source: any) => {\n  const buffer = await renderSong(source),\n    node = zzfxP(...buffer);\n  node.loop = true;\n  zzfxX.resume();\n};\n\nconst renderSong = async (song: any): Promise<any[][]> => {\n  await timeout(50);\n  return zzfxM(...song);\n};\n\nexport { audioContext, unlockAudio, playMusic };\n", "import { canvas } from \"./graphics\";\nimport { unlockAudio } from \"../resources/sound/audio\";\nimport { domDocument } from \"../utils/browser\";\n\nconst keys: { [key: string]: boolean } = {};\nexport let anyKey = false;\n\nexport const initInput = () => {\n    domDocument.onkeydown = (e) => {\n        unlockAudio();\n        anyKey = true;\n        keys[e.keyCode] = true;\n        e.preventDefault();\n    }\n\n    domDocument.onkeyup = (e) => {\n        anyKey = false;\n        unpressKey(e.keyCode);\n        e.preventDefault();\n    }\n\n    canvas.onmousedown = () => {\n        unlockAudio();\n    }\n\n    canvas.ontouchstart = () => {\n        unlockAudio();\n    }\n}\n\nexport const enum Key {\n    Up = 38,\n    Down = 40,\n    Left = 37,\n    Right = 39,\n    A = 65,\n    D = 68,\n    W = 87,\n    S = 83,\n    Z = 90,\n    X = 88,\n    Enter = 13,\n    Space = 32,\n}\n\nexport const isKeyPressed = (code: Key): boolean | undefined => keys[code];\nexport const unpressKey = (code: Key) => delete keys[code];", "import { isKeyPressed, Key } from \"../engine/input\";\nimport { addUnit, Unit, UnitConfig } from \"../engine/unit\";\nimport { kate0, kate1, kate10, kate11, kate12, kate13, kate2, kate3, kate4, kate5, kate6, kate7, kate8, kate9 } from \"../resources/id\";\n\nconst config: UnitConfig = {\n    mob: false,\n    health: 1000,\n    walkSpeed: 30,\n    offset: { x: 16, y: 29 },\n    animations: {\n        stand: [\n            { image: kate0, time: 0.2 },\n            { image: kate1, time: 0.2 },\n            { image: kate2, time: 0.2 },\n            { image: kate1, time: 0.2 },\n            { image: kate0, time: 0.2 },\n            { image: kate3, time: 0.2 },\n        ],\n        walkH: [\n            { image: kate0, time: 0.1 },\n            { image: kate4, time: 0.1 },\n            { image: kate5, time: 0.1 },\n            { image: kate4, time: 0.1 },\n        ],\n        walkV: [\n            { image: kate11, time: 0.1 },\n            { image: kate12, time: 0.1 },\n            { image: kate11, time: 0.1 },\n            { image: kate13, time: 0.1 },\n        ],\n        jab: [\n            { image: kate0, time: 0.05 },\n            { image: kate8, time: 0.1 },\n        ],\n        cross: [\n            { image: kate8, time: 0.1 },\n            { image: kate9, time: 0.1 },\n            { image: kate10, time: 0.1 },\n            { image: kate9, time: 0.1 },\n        ],\n        kick: [\n            { image: kate0, time: 0.05 },\n            { image: kate6, time: 0.05 },\n            { image: kate7, time: 0.1 },\n            { image: kate6, time: 0.1 },\n        ],\n        damage1: [\n            { image: kate0, time: 1.0 },\n        ],\n        damage2: [\n            { image: kate0, time: 1.0 },\n        ],\n        knockdown: [\n            { image: kate0, time: 1.0 },\n        ],\n        dead1: [\n            { image: kate0, time: 1.0 },\n        ],\n        dead2: [\n            { image: kate0, time: 1.0 },\n        ]\n    },\n    damages: {\n        [kate8]: 10, // jab\n        [kate10]: 20, // cross\n        [kate7]: 30, // kick\n    }\n};\n\nlet hero: Unit | undefined;\n\nexport const createHero = () => {\n    hero = addUnit(config);\n}\n\nexport const getHero = (): Unit => {\n    return hero!;\n}\n\nexport const updateHero = () => {\n    if (!hero) {\n        return;\n    }\n\n    if (hero.health <= 0) {\n        return;\n    }\n\n    hero.controller.move.x = 0;\n    hero.controller.move.y = 0;\n    hero.controller.leg = false;\n    hero.controller.hand = false;\n\n    if (isKeyPressed(Key.Left) || isKeyPressed(Key.A)) {\n        hero.controller.move.x = -1;\n    }\n\n    if (isKeyPressed(Key.Right) || isKeyPressed(Key.D)) {\n        hero.controller.move.x = 1;\n    }\n\n    if (isKeyPressed(Key.Up) || isKeyPressed(Key.W)) {\n        hero.controller.move.y = -1;\n    }\n\n    if (isKeyPressed(Key.Down) || isKeyPressed(Key.S)) {\n        hero.controller.move.y = 1;\n    }\n\n    if (isKeyPressed(Key.Z)) {\n        hero.controller.leg = true;\n    }\n\n    if (isKeyPressed(Key.X)) {\n        hero.controller.hand = true;\n    }\n}", "// Wave shapes\n\nconst SQUARE = 0;\nconst SAWTOOTH = 1;\nconst SINE = 2;\nconst NOISE = 3;\n\nconst p_wave = 0;\nconst p_env_attack = 1;\nconst p_env_sustain = 2;\nconst p_env_punch = 3;\nconst p_env_decay = 4\nconst p_base_freq = 5\nconst p_freq_limit = 6\nconst p_freq_ramp = 7\nconst p_freq_dramp = 8\nconst p_vib_strength = 9\nconst p_vib_speed = 10\nconst p_arp_mod = 11\nconst p_arp_speed = 12\nconst p_duty = 13\nconst p_duty_ramp = 14\nconst p_repeat_speed = 15\nconst p_pha_offset = 16\nconst p_pha_ramp = 17\nconst p_lpf_freq = 18\nconst p_lpf_ramp = 19\nconst p_lpf_resonance = 20\nconst p_hpf_freq = 21\nconst p_hpf_ramp = 22\n\n// render volume\nconst masterVolume = 1;\nconst OVERSAMPLING = 8;\n// default sample parameters\nconst base_sound_vol = 0.5;\nconst gain = masterVolume * (Math.exp(base_sound_vol) - 1);\n\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nfunction render(ps: Float32Array): Float32Array {\n\tlet elapsedSinceRepeat = 0;\n\n\tconst period0 = ps[p_base_freq];\n\tconst periodMax = Math.abs(ps[p_freq_limit]);\n\tconst enableFrequencyCutoff = ps[p_freq_limit] > 0;\n\tconst periodMult0 = ps[p_freq_ramp];\n\tconst periodMultSlide = ps[p_freq_dramp];\n\tconst dutyCycle0 = ps[p_duty];\n\tconst dutyCycleSlide0 = ps[p_duty_ramp];\n\tconst arpeggioMultiplier = ps[p_arp_mod];\n\tconst arpeggioTime0 = ps[p_arp_speed];\n\n\t// init repeat\n\tlet period = period0;\n\tlet periodMult = periodMult0;\n\tlet dutyCycle = dutyCycle0;\n\tlet dutyCycleSlide = dutyCycleSlide0;\n\tlet arpeggioTime = arpeggioTime0;\n\n\t// Waveform shape\n\tconst waveShape = ps[p_wave];\n\n\t// Filter\n\tlet fltw = ps[p_lpf_freq];\n\tconst enableLowPassFilter = (fltw !== 0.1);\n\tconst fltw_d = ps[p_lpf_ramp];\n\tconst fltdmp = ps[p_lpf_resonance];\n\tlet flthp = ps[p_hpf_freq];\n\tconst flthp_d = ps[p_hpf_ramp];\n\n\t// Vibrato\n\tconst vibratoSpeed = ps[p_vib_speed];\n\tconst vibratoAmplitude = ps[p_vib_strength];\n\n\t// Envelope\n\tconst envelopeLength = [\n\t\tps[p_env_attack],\n\t\tps[p_env_sustain],\n\t\tps[p_env_decay],\n\t];\n\tconst envelopePunch = ps[p_env_punch];\n\n\t// Flanger\n\tlet flangerOffset = ps[p_pha_offset];\n\tconst flangerOffsetSlide = ps[p_pha_ramp];\n\n\t// Repeat\n\tconst repeatTime = ps[p_repeat_speed];\n\n\t////////// RENDER\n\tlet fltp = 0;\n\tlet fltdp = 0;\n\tlet fltphp = 0;\n\n\tlet noise_buffer = new Float32Array(32);\n\tfor (let i = 0; i < 32; ++i) {\n\t\tnoise_buffer[i] = Math.random() * 2 - 1;\n\t}\n\n\tlet envelopeStage = 0;\n\tlet envelopeElapsed = 0;\n\n\tlet vibratoPhase = 0;\n\n\tlet phase = 0;\n\tlet ipp = 0;\n\tlet flanger_buffer = new Float32Array(1024);\n\tfor (let i = 0; i < 1024; ++i) {\n\t\tflanger_buffer[i] = 0;\n\t}\n\n\tlet normalized: number[] = [];\n\n\tfor (let t = 0; ; ++t) {\n\n\t\t// Repeats\n\t\tif (repeatTime !== 0 && ++elapsedSinceRepeat >= repeatTime) {\n\t\t\t// INIT REPEAT\n\t\t\tperiod = period0;\n\t\t\tperiodMult = periodMult0;\n\t\t\tdutyCycle = dutyCycle0;\n\t\t\tdutyCycleSlide = dutyCycleSlide0;\n\t\t\tarpeggioTime = arpeggioTime0;\n\t\t}\n\n\t\t// Arpeggio (single)\n\t\tif (arpeggioTime !== 0 && t >= arpeggioTime) {\n\t\t\tarpeggioTime = 0;\n\t\t\tperiod *= arpeggioMultiplier;\n\t\t}\n\n\t\t// Frequency slide, and frequency slide slide!\n\t\tperiodMult += periodMultSlide;\n\t\tperiod *= periodMult;\n\t\tif (period > periodMax) {\n\t\t\tperiod = periodMax;\n\t\t\tif (enableFrequencyCutoff) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Vibrato\n\t\tlet rfperiod = period;\n\t\tif (vibratoAmplitude > 0) {\n\t\t\tvibratoPhase += vibratoSpeed;\n\t\t\trfperiod = period * (1 + Math.sin(vibratoPhase) * vibratoAmplitude);\n\t\t}\n\t\tlet iperiod = Math.floor(rfperiod);\n\t\tif (iperiod < OVERSAMPLING) {\n\t\t\tiperiod = OVERSAMPLING;\n\t\t}\n\n\t\t// Square wave duty cycle\n\t\tdutyCycle += dutyCycleSlide;\n\t\tif (dutyCycle < 0) {\n\t\t\tdutyCycle = 0;\n\t\t}\n\t\tif (dutyCycle > 0.5) {\n\t\t\tdutyCycle = 0.5;\n\t\t}\n\n\t\t// Volume envelope\n\t\tif (++envelopeElapsed > envelopeLength[envelopeStage]) {\n\t\t\tenvelopeElapsed = 0;\n\t\t\tif (++envelopeStage > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst envf = envelopeElapsed / envelopeLength[envelopeStage];\n\t\tlet env_vol;\n\t\tif (envelopeStage === 0) {         // Attack\n\t\t\tenv_vol = envf;\n\t\t} else if (envelopeStage === 1) {  // Sustain\n\t\t\tenv_vol = 1 + (1 - envf) * 2 * envelopePunch;\n\t\t} else {                           // Decay\n\t\t\tenv_vol = 1 - envf;\n\t\t}\n\n\t\t// Flanger step\n\t\tflangerOffset += flangerOffsetSlide;\n\t\tlet iphase = Math.abs(Math.floor(flangerOffset));\n\t\tif (iphase > 1023) {\n\t\t\tiphase = 1023;\n\t\t}\n\n\t\tif (flthp_d !== 0) {\n\t\t\tflthp *= flthp_d;\n\t\t\tif (flthp < 0.00001) {\n\t\t\t\tflthp = 0.00001;\n\t\t\t}\n\t\t\tif (flthp > 0.1) {\n\t\t\t\tflthp = 0.1;\n\t\t\t}\n\t\t}\n\n\t\t// 8x oversampling\n\t\tlet sample = 0;\n\t\tfor (let si = 0; si < OVERSAMPLING; ++si) {\n\t\t\tlet sub_sample = 0;\n\t\t\t++phase;\n\t\t\tif (phase >= iperiod) {\n\t\t\t\tphase %= iperiod;\n\t\t\t\tif (waveShape === NOISE) {\n\t\t\t\t\tfor (let i = 0; i < 32; ++i) {\n\t\t\t\t\t\tnoise_buffer[i] = Math.random() * 2 - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Base waveform\n\t\t\tconst fp = phase / iperiod;\n\t\t\tif (waveShape === SQUARE) {\n\t\t\t\tsub_sample = fp < dutyCycle ? 0.5 : -0.5;\n\t\t\t} else if (waveShape === SAWTOOTH) {\n\t\t\t\tif (fp < dutyCycle) {\n\t\t\t\t\tsub_sample = -1 + 2 * fp / dutyCycle;\n\t\t\t\t} else {\n\t\t\t\t\tsub_sample = 1 - 2 * (fp - dutyCycle) / (1 - dutyCycle);\n\t\t\t\t}\n\t\t\t} else if (waveShape === SINE) {\n\t\t\t\tsub_sample = Math.sin(fp * 2 * Math.PI);\n\t\t\t} else if (waveShape === NOISE) {\n\t\t\t\tsub_sample = noise_buffer[(phase * 32 / iperiod) | 0];\n\t\t\t} else {\n\t\t\t\t// no-op; invalid wave shape\n\t\t\t}\n\n\t\t\t// Low-pass filter\n\t\t\tconst pp = fltp;\n\t\t\tfltw *= fltw_d;\n\t\t\tif (fltw < 0) {\n\t\t\t\tfltw = 0;\n\t\t\t}\n\t\t\tif (fltw > 0.1) {\n\t\t\t\tfltw = 0.1;\n\t\t\t}\n\t\t\tif (enableLowPassFilter) {\n\t\t\t\tfltdp += (sub_sample - fltp) * fltw;\n\t\t\t\tfltdp -= fltdp * fltdmp;\n\t\t\t} else {\n\t\t\t\tfltp = sub_sample;\n\t\t\t\tfltdp = 0;\n\t\t\t}\n\t\t\tfltp += fltdp;\n\n\t\t\t// High-pass filter\n\t\t\tfltphp += fltp - pp;\n\t\t\tfltphp -= fltphp * flthp;\n\t\t\tsub_sample = fltphp;\n\n\t\t\t// Flanger\n\t\t\tflanger_buffer[ipp & 1023] = sub_sample;\n\t\t\tsub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n\t\t\tipp = (ipp + 1) & 1023;\n\n\t\t\t// final accumulation and envelope application\n\t\t\tsample += sub_sample * env_vol;\n\t\t}\n\n\t\t// store normalized floating point sample\n\t\tnormalized.push(sample * gain / OVERSAMPLING);\n\t}\n\n\treturn new Float32Array(normalized);\n}\n\nexport function createAudioBuffer(audioContext: AudioContext, params: Float32Array): AudioBuffer {\n\tconst samples = render(params);\n\tconst audioBuffer = audioContext.createBuffer(1, samples.length, 44100);\n\taudioBuffer.copyToChannel(samples, 0, 0);\n\treturn audioBuffer;\n}", "import { DEBUG } from \"../debug\";\nimport { hasTouch } from \"../utils/browser\";\nimport { createAudioBuffer } from \"./sfxr\";\n\nlet audioContext: AudioContext | undefined = undefined;\n\nexport const soundsBuffers: ArrayBuffer[] = [];\nconst sounds: AudioBuffer[] = [];\n\nconst masterVolume = 0.05;\n\nif (!hasTouch) {\n    initSound();\n}\n\nexport function initSound() {\n    if (!audioContext) {\n        audioContext = new AudioContext();\n\n        if (DEBUG) {\n            console.log(\"sound inited\");\n        }\n    }\n}\n\nexport function playSound(id: number, volume: number = 1.0) {\n    if (audioContext) {\n        if (!sounds[id]) {\n            sounds[id] = createAudioBuffer(audioContext, new Float32Array(soundsBuffers[id]));\n        }\n\n        const source = audioContext.createBufferSource();\n        source.buffer = sounds[id];\n\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = masterVolume * volume;\n        source.connect(gainNode);\n        gainNode.connect(audioContext.destination);\n\n        source.start();\n    }\n}", "import { createContext, getCanvas, setHeight, setWidth } from \"../utils/browser\";\nimport { images } from \"./images\";\nimport { soundsBuffers } from \"./sounds\";\n\nexport async function loadResources() {\n    const response = await fetch('r');\n    const buffer = await response.arrayBuffer();\n\n    const stream = new Uint8Array(buffer);\n\n    let p = 0;\n\n    const palletteSize = stream[p++] * 4;\n    const pallette = stream.slice(p, p + palletteSize);\n    p += palletteSize;\n\n    let imagesLength = stream[p++];\n\n    while (imagesLength--) {\n        const width = stream[p++];\n        const height = stream[p++];\n\n        const imageSize = width * height;\n\n        const pixels = stream.slice(p, p + imageSize);\n        p += imageSize;\n\n        let context = createContext();\n        setWidth(context, width);\n        setHeight(context, height);\n\n        let imageData = context.getImageData(0, 0, width, height);\n\n        for (let p = 0; p < pixels.length; p++) {\n            let c = pixels[p] << 2;\n\n            imageData.data.set(pallette.slice(c, c + 4), p << 2);\n        }\n\n        context.putImageData(imageData, 0, 0);\n\n        images.push(getCanvas(context));\n    }\n\n    let soundsLength = stream[p++];\n\n    while (soundsLength--) {\n        const soundSize = stream[p++];\n        soundsBuffers.push(buffer.slice(p, p + soundSize));\n        p += soundSize;\n    }\n}", "export default [[[.6,0,100,,,.2,1,.5,,-10,,,,3,,,,10],[.7,0,110,,,.2,2,.1,,,,,,,,,,,.1,.4],[1.3,0,300,,,0,4,3,,,300,,,1,,,,.3,.2],[,0,,,.13,.7,2,.2,,,,,.04,.3,,.02,1,,.3,.1],[3,0,60,,,,3,.2,,,,.5,,.6,1,.05],[,0],[,0]],[[[,-.1,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,],[2,.1,,,,,1,,,,,,,,1,,,,,,,,1,,,,,,,,1,,,1,,,,,1,,,,,,,,1,,,,,,,,1,,,,,,,,1,,1,1],[1,.1,1,,13,,1,,13,,1,,13,,1,,13,,1,,13,,1,,13,,1,,13,,1,,13,,4,,16,,4,,16,,4,,16,,4,,16,,4,,16,,4,,16,,3,,15,,3,,15,,],[3,.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,]],[[,-.1,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,],[2,.1,1,,,,1,,,,,,,,1,,,,,,,,1,,,,,,,,1,,,1,,,,,1,,,,,,,,1,,,,,,,,1,,,,,,,,1,,1,1],[1,.1,1,,13,13,1,,13,13,1,,13,,1,,13,13,1,,13,13,1,,13,,1,,13,13,1,,13,13,4,,16,16,4,,16,16,4,,16,,4,,16,16,4,,16,16,4,,16,16,3,,15,15,3,,15,15],[3,.4,,,,,20,,,,,,23,,,,,,25,,,,,,27,,,,,,25,,,,27,,,,,,,,,,,,,,,,28,,27,,,,25,,,,27,,,,25,,]]],[0,0,1,1],,]", "import { Stage } from \"../../engine/stage\";\nimport { barFloor0, barFloor1, barFloor2, barFloor3, barWall0, barWall1, barWall2, barWall3, barWall4, barWall5 } from \"../../resources/id\";\nimport { addImage, images } from \"../../resources/images\";\nimport { createCanvas, drawImage, getContext } from \"../../utils/browser\"\nimport { drawCommands, drawGradientV, generateRandomTileImage, generateTileImage } from \"../../utils/image\";\nimport { mathRandom, randomChancesSelect, randomSelect } from \"../../utils/math\";\n\nexport const getBarStage = (): Stage => {\n    const floorWidth = 400;\n    const floorHeight = 150;\n    const wallHeight = 95;\n\n    const floorCanvas = generateFloorImage(floorWidth, floorHeight);\n    const wallCanvas = generateWallImage(floorWidth, wallHeight);\n\n    const backCanvas = createCanvas();\n    const backContext = getContext(backCanvas);\n    backCanvas.width = floorWidth;\n    backCanvas.height = floorHeight + wallHeight;\n    drawImage(backContext, wallCanvas, 0, 0);\n    drawImage(backContext, floorCanvas, 0, wallHeight);\n\n    const back = addImage(backCanvas);\n\n    const borderX = 10;\n    const borderY = 5;\n\n    return {\n        bounds: {\n            x: borderX,\n            y: wallHeight + borderY,\n            w: floorWidth - borderX * 2,\n            h: floorHeight - borderY * 2,\n        },\n        back: { image: back },\n        camera: { x: 0, y: 0 },\n    }\n}\n\nconst generateFloorImage = (width: number, height: number): HTMLCanvasElement => {\n    const image = generateRandomTileImage(width, height, [barFloor0, barFloor1, barFloor2, barFloor3], [3, 2, 1, 1]);\n    const context = getContext(image);\n\n    const border = 30;\n\n    context.fillStyle = \"black\";\n    context.fillRect(0, 0, image.width, 1);\n\n    drawGradientV(context, 0, 0, image.width, border, 0x77000000, 0);\n    drawGradientV(context, 0, image.height - border, image.width, border, 0, 0x77000000);\n\n    noise(10, image);\n\n    return image;\n}\n\nconst generateWallImage = (width: number, height: number): HTMLCanvasElement => {\n    const image = generateTileImage(width, height, barWall0);\n    const context = getContext(image);\n\n    const columns = [barWall1, barWall2, barWall3];\n    const columnsChances = [2, 1, 1];\n\n    const columnStep = 50;\n\n    for (let x = 0; x < width; x += columnStep) {\n        for (let y = 0; y < width; y += 16) {\n            const columnImage = images[randomChancesSelect(columns, columnsChances)];\n            drawImage(context, columnImage, x, y);\n        }\n    }\n\n    drawCommands(\n        [\n            barWall4, columnStep - 13, 0,\n            barWall4, columnStep * 3 - 13, 0,\n            barWall4, columnStep * 6 - 13, 0,\n\n            barWall5, columnStep * 2 - 17, 0,\n            barWall5, columnStep * 5 - 30, 0\n        ],\n        context,\n    )\n\n    const border = 40;\n    drawGradientV(context, 0, image.height - border, image.width, border, 0, 0x77000000);\n\n    noise(10, image);\n\n    return image;\n}\n\nexport const noise = (offset: number, canvas: HTMLCanvasElement) => {\n    const context = getContext(canvas);\n    const offset2 = offset / 2;\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    const data = imageData.data;\n    let i = 0;\n    while (i < data.length) {\n        const r = data[i];\n        const g = data[i + 1];\n        const b = data[i + 2];\n        data[i] = r - offset2 + offset * mathRandom();\n        data[i + 1] = g - offset2 + offset * mathRandom();\n        data[i + 2] = b - offset2 + offset * mathRandom();\n        i += 4;\n    }\n    context.putImageData(imageData, 0, 0);\n}\n", "import { getStage, setStage } from \"../engine/stage\"\nimport { clearUnits } from \"../engine/unit\";\nimport { createHero, getHero } from \"./hero\";\nimport { createMob } from \"./mob\";\nimport { getBarStage } from \"./stages/bar\"\n\nexport const start = () => {\n    setStage(getBarStage());\n    clearUnits();\n    createHero();\n\n    const stage = getStage();\n\n    // const bob = createMob(0);\n    // bob.position.x = stage.bounds.x + 100;\n    // bob.position.y = stage.bounds.y + stage.bounds.h / 2;\n\n    // const jack = createMob(1);\n    // jack.position.x = stage.bounds.x + 120;\n    // jack.position.y = stage.bounds.y + stage.bounds.h / 2 + 20;\n\n    const hero = getHero();\n    hero.position.x = stage.bounds.x + 50;\n    hero.position.y = stage.bounds.y + stage.bounds.h / 2;\n}", "import { gameHeight, gameWidth } from \"../engine/graphics\";\nimport { getStage } from \"../engine/stage\";\nimport { getHero } from \"./hero\";\n\nexport const updateCameraPosition = () => {\n    const stage = getStage();\n    const hero = getHero();\n\n    stage.camera.x = hero.position.x - gameWidth / 2;\n    stage.camera.y = hero.position.y - gameHeight / 2;\n}", "import { AnimationFrame } from \"../engine/animation\";\nimport { getStage } from \"../engine/stage\";\nimport { addUnit, Unit, UnitConfig, units, UnitState } from \"../engine/unit\";\nimport { man0, man1, man10, man11, man12, man2, man3, man4, man5, man6, man7, man8, man9, man13, man14, man15, man16, man17, man18, man19, man20, man21 } from \"../resources/id\";\nimport { addImage, images } from \"../resources/images\";\nimport { cloneObject } from \"../utils/browser\";\nimport { Vector2 } from \"../utils/geom\";\nimport { applyPallette, cloneCanvas } from \"../utils/image\";\nimport { chance, mathRandom, randomRange } from \"../utils/math\";\nimport { getHero } from \"./hero\";\n\nexport const mobs: Array<Unit> = [];\n\nconst pallette = [\n    0xff000000, // hair\n    0xffff9300, // face\n    0xff942192, // body\n    0xffaa7942, // hand0\n    0xff5e0e01, // hand1\n    0xffbf6d5e, // hand2\n    0xff006500, // legs0\n    0xff006a6b, // legs1\n    0xff01187d, // legs2\n];\n\nconst config: UnitConfig = {\n    mob: true,\n    health: 100,\n    walkSpeed: 20,\n    offset: { x: 16, y: 31 },\n    animations: {\n        stand: [\n            { image: man0, time: 0.3 },\n            { image: man1, time: 0.3 },\n            { image: man0, time: 0.3 },\n            { image: man2, time: 0.3 },\n            { image: man3, time: 0.3 },\n            { image: man2, time: 0.3 },\n        ],\n        walkH: [\n            { image: man0, time: 0.2 },\n            { image: man4, time: 0.2 },\n            { image: man0, time: 0.2 },\n            { image: man5, time: 0.2 },\n        ],\n        walkV: [\n            { image: man0, time: 0.2 },\n            { image: man9, time: 0.2 },\n            { image: man0, time: 0.2 },\n            { image: man10, time: 0.2 },\n        ],\n        jab: [\n            { image: man0, time: 0.2 },\n            { image: man6, time: 0.2 },\n        ],\n        cross: [\n            { image: man6, time: 0.2 },\n            { image: man7, time: 0.2 },\n            { image: man8, time: 0.2 },\n            { image: man7, time: 0.2 },\n        ],\n        kick: [\n            { image: man0, time: 0.2 },\n            { image: man11, time: 0.2 },\n            { image: man12, time: 0.2 },\n            { image: man11, time: 0.2 },\n        ],\n        damage1: [\n            { image: man14, time: 0.5 },\n            { image: man13, time: 0.3 },\n        ],\n        damage2: [\n            { image: man18, time: 0.5 },\n            { image: man17, time: 0.3 },\n        ],\n        knockdown: [\n            { image: man13, time: 0.2 },\n            { image: man14, time: 0.5 },\n            { image: man15, time: 1.0 },\n            { image: man16, time: 0.3 },\n            { image: man17, time: 0.2 },\n        ],\n        dead1: [\n            { image: man18, time: 0.2 },\n            { image: man19, time: 0.2 },\n            { image: man20, time: 0.2 },\n            { image: man21, time: 5.0 },\n        ],\n        dead2: [\n            { image: man13, time: 0.2 },\n            { image: man14, time: 0.5 },\n            { image: man15, time: 1.0 },\n        ]\n    },\n    damages: {\n        [man6]: 5, // jab\n        [man8]: 10, // cross\n        [man12]: 20, // kick\n    }\n};\n\nconst configs: Array<UnitConfig> = [];\n\nexport const generateMobsConfigs = () => {\n    // const pallette = getPallette(images[man0]);\n    // for (const color of pallette) {\n    //     console.log(`0x${color.toString(16)}`);\n    // }\n\n    configs.push(generateConfig([\n        0xff000000, // hair\n        0xffff9300, // face\n        0xff333333, // body\n        0xff333333, // hand0\n        0xff999999, // hand1\n        0xffff9300, // hand2\n        0xff000033, // legs0\n        0xff000033, // legs1\n        0xff000000, // legs2\n    ], \"bob\"));\n\n    configs.push(generateConfig([\n        0xff000000, // hair\n        0xffff9300, // face\n        0xff71B8D5, // body\n        0xffff9300, // hand0\n        0xffff9300, // hand1\n        0xff000000, // hand2\n        0xff797B8B, // legs0\n        0xff797B8B, // legs1\n        0xff000000 // legs2\n    ], \"jack\"));\n}\n\nconst generateConfig = (targetPallette: number[], palletteName: string): UnitConfig => {\n    const newConfig: UnitConfig = cloneObject(config);\n\n    newConfig.walkSpeed = randomRange(10, 20);\n\n    const animations = newConfig.animations as any;\n    for (const name in animations) {\n        const animation = animations[name] as Array<AnimationFrame>;\n        replaceImagesPallette(animation, pallette, targetPallette, palletteName);\n    }\n\n    return newConfig;\n}\n\nconst replaceImagesPallette = (animation: Array<AnimationFrame>, sourcePallette: Array<number>, targetPallette: Array<number>, palletteName: string) => {\n    for (const frame of animation) {\n        frame.image = getPalletteImage(frame.image, sourcePallette, targetPallette, palletteName);\n    }\n}\n\nconst imagesPallete: { [key: string]: number } = {};\nconst getPalletteImage = (id: number, sourcePallette: Array<number>, targetPallette: Array<number>, palletteName: string) => {\n    const key = `${id}_${palletteName}`;\n    if (!imagesPallete[key]) {\n        const target = cloneCanvas(images[id]);\n        applyPallette(target, sourcePallette, targetPallette);\n        imagesPallete[key] = addImage(target);\n    }\n    return imagesPallete[key];\n}\n\nexport const createMob = (index: number): Unit => {\n    const mob = addUnit(configs[index]);\n    mobs.push(mob);\n    return mob;\n}\n\nexport const clearMobs = () => {\n    mobs.splice(0, mobs.length);\n}\n\nexport const removeMob = (mob: Unit) => {\n    const index = mobs.indexOf(mob);\n    if (index != -1) {\n        mobs.splice(index, 1);\n    }\n}\n\nexport const updateMobs = () => {\n    const hero = getHero();\n\n    for (const mob of mobs) {\n        updateMob(mob, hero);\n    }\n}\n\nconst updateMob = (mob: Unit, hero: Unit) => {\n    if (units.indexOf(mob) == -1) {\n        removeMob(mob);\n    }\n\n    if (mob.health <= 0) {\n        return;\n    }\n\n    mob.controller.move.x = 0;\n    mob.controller.move.y = 0;\n    mob.controller.leg = false;\n    mob.controller.hand = false;\n    mob.controller.cross = false;\n\n    const fightDistance = 15;\n\n    if (mob.state == UnitState.Stand || mob.state == UnitState.Walk) {\n        const direction = Vector2.subtract(hero.position, mob.position);\n        const distance = Vector2.length(direction);\n\n        if (distance > fightDistance) {\n            Vector2.normalize(direction);\n            mob.controller.move.x = direction.x;\n            mob.controller.move.y = direction.y;\n        } else {\n            mob.controller.move.x = 0;\n            mob.controller.move.y = 0;\n\n            const rnd = mathRandom();\n            if (rnd < 0.5) {\n                mob.controller.hand = true;\n            } else if (rnd < 0.8) {\n                mob.controller.cross = true;\n            } else {\n                mob.controller.leg = true;\n            }\n        }\n    }\n}\n\nexport const generateMobs = () => {\n    if (mobs.length < 2) {\n        const stage = getStage();\n\n        const bob = chance(0.5) ? createMob(0) : createMob(1);\n        bob.position.x = stage.bounds.x + 100 + randomRange(-40, 40);\n        bob.position.y = stage.bounds.y + stage.bounds.h / 2 + randomRange(-40, 40);\n    }\n}", "import { DEBUG } from \"./debug\";\nimport { initInput } from \"./engine/input\";\nimport { applyUnitsDamage, limitUnitsPositions, updateUnits, updateUnitsSpritePositions } from \"./engine/unit\";\nimport { updateHero } from \"./game/hero\";\nimport { draw, updateSize } from \"./engine/graphics\";\nimport { loadResources } from \"./resources/loader\";\nimport { playMusic } from \"./resources/sound/audio\";\nimport { calculateTime } from \"./utils/time\";\nimport background from \"./resources/background\";\nimport { start } from \"./game/start\";\nimport { updateCameraPosition } from \"./game/game\";\nimport { limitCamera } from \"./engine/stage\";\nimport { generateMobs, generateMobsConfigs, updateMobs } from \"./game/mob\";\nimport { updateEffects } from \"./engine/effect\";\n\nif (DEBUG) {\n    console.warn(\"debug mode\");\n    new EventSource('/esbuild').addEventListener('change', () => location.reload())\n}\n\nconst update = () => {\n    calculateTime();\n    updateSize();\n\n    updateHero();\n    updateMobs();\n    updateUnits();\n    applyUnitsDamage();\n    limitUnitsPositions();\n    updateEffects();\n    generateMobs();\n\n    updateCameraPosition();\n    limitCamera();\n    updateUnitsSpritePositions();\n\n    draw();\n\n    requestAnimationFrame(update);\n};\n\nasync function main() {\n    await loadResources();\n    playMusic(background);\n    initInput();\n    generateMobsConfigs();\n    start();\n    update();\n}\n\nmain();"],
  "mappings": "mBAAA,IAAMA,EAAO,KAEAC,GAAYD,EAAK,MACjBE,GAAWF,EAAK,KAChBG,EAAYH,EAAK,MACjBI,GAAUJ,EAAK,IACfK,GAAUL,EAAK,IACfM,GAAYN,EAAK,MACjBO,GAAUP,EAAK,IACfQ,EAAaR,EAAK,OAClBS,GAAYT,EAAK,MACjBU,GAASV,EAAK,GACdW,GAAUD,GAAS,EACnBE,GAAY,OAAO,UAEnBC,GAAQ,CAACC,EAAaC,EAAaC,IAAkBZ,GAAQW,EAAKV,GAAQS,EAAKE,CAAK,CAAC,EACrFC,GAAO,CAACH,EAAaC,EAAaC,IAAkBF,EAAME,GAASD,EAAMD,GACzEI,EAAc,CAACJ,EAAaC,IAAwBE,GAAKH,EAAKC,EAAKP,EAAU,CAAE,EAC/EW,GAAUA,GAA4BX,EAAU,EAAKW,EAE5D,SAAUC,GAAgBC,EAAW,CACvC,OAAOA,EAAOlB,EAAUe,EAAY,EAAGG,EAAO,OAAS,CAAC,CAAC,CAAC,CAC9D,CAEM,SAAUC,GAAuBD,EAAaE,EAAsB,CACtE,IAAMC,EAAQD,EAAQ,OAAO,CAACE,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAEzCP,EAASX,EAAU,EAAKgB,EAE1BE,EAAI,EAER,QAAQC,EAAI,EAAGA,EAAIN,EAAO,OAAQM,IAE9B,GADAD,GAAKH,EAAQI,CAAC,EACVR,EAASO,EACT,OAAOL,EAAOM,CAAC,EAIvB,OAAON,EAAO,CAAC,CACnB,CCrCO,IAAMO,GAAc,SACdC,GAAW,iBAAkB,OAG1C,IAAMC,GAAa,SAENC,EAAcC,GAA8BA,EAAO,WAAW,IAAI,EAClEC,EAAe,IAAMC,GAAY,cAAcJ,EAAU,EACzDK,GAAgB,IAAMJ,EAAWE,EAAY,CAAE,EAC/CG,GAAaC,GAAsCA,EAAQ,OAGjE,IAAMC,GAAW,CAACC,EAAmCC,IAAkBC,GAAUF,CAAO,EAAE,MAAQC,EAC5FE,GAAY,CAACH,EAAmCI,IAAmBF,GAAUF,CAAO,EAAE,OAASI,EAErG,IAAMC,EAAY,CAACC,EAAmCC,EAA0BC,EAAWC,IAAcH,EAAQ,UAAUC,EAAOG,EAAUF,CAAC,EAAGE,EAAUD,CAAC,CAAC,EAG5J,IAAME,GAAM,IAAM,YAAY,IAAG,EAE3BC,GAAeC,GAAqB,KAAK,MAAM,KAAK,UAAUA,CAAM,CAAC,EAElF,eAAsBC,GAAQC,EAAY,CACtC,OAAO,IAAI,QAASC,GAAW,CAC3B,WAAWA,EAASD,CAAI,CAC5B,CAAC,CACL,CC5BO,IAAME,GAAeC,GAAqB,CAC7C,IAAMC,EAAID,GAAK,GAAK,IACdE,EAAIF,GAAK,GAAK,IACdG,EAAIH,GAAK,EAAI,IACbI,EAAIJ,EAAI,IAEd,MAAO,QAAQE,CAAC,KAAKC,CAAC,KAAKC,CAAC,KAAKH,EAAI,GAAI,GAC7C,EAEaI,GAAiB,CAC1BC,EACAC,EAAYC,EAAYC,EAAYC,EACpCC,EAAoBC,IACpB,CACA,IAAMC,EAAWP,EAAQ,qBAAqBC,EAAIC,EAAIC,EAAIC,CAAE,EAC5D,OAAAG,EAAS,aAAa,EAAGd,GAAYY,CAAU,CAAC,EAChDE,EAAS,aAAa,EAAGd,GAAYa,CAAQ,CAAC,EACvCC,CACX,ECbO,IAAMC,GAA0B,CAACC,EAAeC,EAAgBC,EAAoBC,IAA6C,CACpI,IAAMC,EAASC,EAAY,EACrBC,EAAUC,EAAWH,CAAM,EAE7BI,EAAQC,EAAOP,EAAI,CAAC,CAAC,EAEzBE,EAAO,MAAQJ,EACfI,EAAO,OAASH,EAEhB,IAAMS,EAAKC,GAASX,EAAQQ,EAAM,KAAK,EACjCI,EAAKD,GAASV,EAASO,EAAM,MAAM,EAEzC,QAASK,EAAI,EAAGA,EAAIH,EAAIG,IACpB,QAASC,EAAI,EAAGA,EAAIF,EAAIE,IACpBN,EAAQC,EAAOM,GAAoBb,EAAKC,CAAO,CAAC,EAChDG,EAAQ,UAAUE,EAAOK,EAAIL,EAAM,MAAOM,EAAIN,EAAM,MAAM,EAIlE,OAAOJ,CACX,EAEaY,GAAoB,CAAChB,EAAeC,EAAgBgB,IAAsC,CACnG,IAAMb,EAASC,EAAY,EACrBC,EAAUC,EAAWH,CAAM,EAEjCA,EAAO,MAAQJ,EACfI,EAAO,OAASH,EAEhB,IAAMO,EAAQC,EAAOQ,CAAO,EAEtBP,EAAKC,GAASX,EAAQQ,EAAM,KAAK,EACjCI,EAAKD,GAASV,EAASO,EAAM,MAAM,EAEzC,QAASK,EAAI,EAAGA,EAAIH,EAAIG,IACpB,QAASC,EAAI,EAAGA,EAAIF,EAAIE,IACpBR,EAAQ,UAAUE,EAAOK,EAAIL,EAAM,MAAOM,EAAIN,EAAM,MAAM,EAIlE,OAAOJ,CACX,EAEac,GAAe,CAACC,EAAyBb,IAAqC,CACvF,QAASc,EAAI,EAAGA,EAAID,EAAS,OAAQC,GAAK,EAAG,CACzC,IAAMC,EAAKF,EAASC,CAAC,EACfP,EAAIM,EAASC,EAAI,CAAC,EAClBN,EAAIK,EAASC,EAAI,CAAC,EAClBZ,EAAQC,EAAOY,CAAE,EACvBC,EAAUhB,EAASE,EAAOK,EAAGC,CAAC,CAClC,CACJ,EAEaS,GAAgB,CAACjB,EAAmCO,EAAWC,EAAWd,EAAeC,EAAgBuB,EAAoBC,IAAoB,CAC1JnB,EAAQ,UAAYoB,GAAepB,EAASO,EAAGC,EAAGD,EAAGC,EAAIb,EAAQuB,EAAYC,CAAQ,EACrFnB,EAAQ,SAASO,EAAGC,EAAGd,EAAOC,CAAM,CACxC,EAOO,IAAM0B,GAAc,CAACC,EAA2BC,IAA8C,CACjG,IAAMC,EAAUC,EAAWH,CAAM,EAC3BI,EAAQJ,EAAO,MACfK,EAASL,EAAO,OAEhBM,EAAYJ,EAAQ,aAAa,EAAG,EAAGE,EAAOC,CAAM,EACpDE,EAASD,EAAU,KAErBE,EAAI,EAER,KAAOA,EAAID,EAAO,QAAQ,CACtB,IAAME,EAAQF,EAAO,MAAMC,EAAGA,EAAI,CAAC,EAEnCP,EAAOQ,CAAK,EAEZF,EAAO,IAAIE,EAAOD,CAAC,EAEnBA,GAAK,CACT,CAEAN,EAAQ,aAAaI,EAAW,EAAG,CAAC,CACxC,EAEaI,GAAeC,GAAgD,CACxE,IAAIC,EAASC,EAAY,EACrBX,EAAUC,EAAWS,CAAM,EAC/B,OAAAA,EAAO,MAAQD,EAAO,MACtBC,EAAO,OAASD,EAAO,OACvBT,EAAQ,UAAUS,EAAQ,EAAG,CAAC,EACvBC,CACX,EAeO,IAAME,GAAgB,CAACC,EAA2BC,EAA+BC,IAAiC,CACrHC,GAAYH,EAASI,GAAS,CAC1B,IAAMC,EAAcC,GAAaF,CAAK,EAEhCG,EAAQN,EAAe,QAAQI,CAAW,EAEhD,GAAIE,GAAS,GAAI,CACb,IAAMC,EAAcN,EAAeK,CAAK,EAExCE,GAAaD,EAAaJ,CAAK,CACnC,CACJ,CAAC,CACL,EAEMM,GAAM,IAAI,YAAY,CAAC,EAEhBJ,GAAgBF,GAAoC,CAC7D,IAAMO,EAAIP,EAAM,CAAC,EACXQ,EAAIR,EAAM,CAAC,EACXS,EAAIT,EAAM,CAAC,EACX,EAAIA,EAAM,CAAC,EAEjB,OAAAM,GAAI,CAAC,EAAK,GAAK,GAAOC,GAAK,GAAOC,GAAK,EAAKC,EAErCH,GAAI,CAAC,CAChB,EAEaD,GAAe,CAACK,EAAeV,IAA4B,CACpE,IAAMW,EAAKD,GAAS,GAAM,IACpBH,EAAKG,GAAS,GAAM,IACpBF,EAAKE,GAAS,EAAK,IACnBD,EAAIC,EAAQ,IAElBV,EAAM,CAAC,EAAIO,EACXP,EAAM,CAAC,EAAIQ,EACXR,EAAM,CAAC,EAAIS,EACXT,EAAM,CAAC,EAAIW,CACf,ECnJO,IAAMC,EAA8B,CAAA,EAErCC,GAA2C,CAAA,EAEpCC,GAAYC,GAAoC,CACzD,IAAMC,EAAKJ,EAAO,OAClB,OAAAA,EAAO,KAAKG,CAAK,EACVC,CACX,EAEaC,GAAkB,CAACD,EAAYE,IAAyB,CACjE,IAAMC,EAAM,GAAGH,CAAE,IAAIE,CAAK,GAC1B,GAAI,CAACL,GAAcM,CAAG,EAAG,CACrB,IAAMC,EAAKF,GAAS,GAAM,IACpBG,EAAKH,GAAS,GAAM,IACpBI,EAAKJ,GAAS,EAAK,IACnBK,EAAIL,EAAQ,IAEZM,EAAeC,GAAYb,EAAOI,CAAE,CAAC,EAE3CU,GAAYF,EAAeN,GAAS,CAChCA,EAAM,CAAC,EAAIG,EACXH,EAAM,CAAC,EAAII,EACXJ,EAAM,CAAC,EAAIK,EACPL,EAAM,CAAC,IACPA,EAAM,CAAC,EAAIE,EAEnB,CAAC,EAEDP,GAAcM,CAAG,EAAIL,GAASU,CAAY,CAC9C,CAEA,OAAOX,GAAcM,CAAG,CAC5B,ECbM,IAAWQ,GAAjB,SAAiBA,EAAO,CACPA,EAAA,UAAaC,GAAc,CACpC,IAAMC,EAAIF,EAAA,OAAOC,CAAC,EACdC,EAAI,IACJD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EAEf,EAEaF,EAAA,OAAUC,GACZE,GAAUF,EAAE,EAAGA,EAAE,CAAC,EAGhBD,EAAA,SAAW,CAACC,EAAYG,IAC1BD,GAAUF,EAAE,EAAIG,EAAE,EAAGH,EAAE,EAAIG,EAAE,CAAC,EAG5BJ,EAAA,IAAM,CAACC,EAAYG,KACrB,CAAE,EAAGH,EAAE,EAAIG,EAAE,EAAG,EAAGH,EAAE,EAAIG,EAAE,CAAC,GAG1BJ,EAAA,SAAW,CAACC,EAAYG,KAC1B,CAAE,EAAGH,EAAE,EAAIG,EAAE,EAAG,EAAGH,EAAE,EAAIG,EAAE,CAAC,GAG1BJ,EAAA,MAAQ,CAACC,EAAYI,KACvB,CAAE,EAAGJ,EAAE,EAAII,EAAG,EAAGJ,EAAE,EAAII,CAAC,EAEvC,GA5BiBL,IAAAA,EAAO,CAAA,EAAA,ECrBjB,IAAIM,GAAgBC,GAAG,EACnBC,EAAiB,EAEfC,GAAgB,IAAK,CAC9B,IAAMC,EAAQJ,GACdA,GAAQC,GAAG,EACXC,GAAUF,GAAQI,GAAS,GAC/B,ECJO,IAAMC,EAAqBC,GAA4C,CAC1E,IAAIC,EAAO,EAEX,QAAWC,KAASF,EAChBC,GAAQC,EAAM,KAGlB,OAAOD,CACX,EAEaE,GAAgB,CAACH,EAAkCI,IAAiC,CAC7F,IAAIH,EAAO,EAELI,EAAYN,EAAkBC,CAAS,EAC7CI,GAAiBC,EAEjB,QAASC,EAAI,EAAGA,EAAIN,EAAU,OAAQM,IAAK,CACvC,IAAMJ,EAAQF,EAAUM,CAAC,EAGzB,GAFAL,GAAQC,EAAM,KAEVE,GAAiBH,EACjB,OAAOC,EAAM,KAErB,CAEA,MAAO,EACX,EAEaK,GAAsB,CAACP,EAAkCI,IAAkC,CACpG,IAAMC,EAAYN,EAAkBC,CAAS,EAC7C,OAAOI,GAAiBC,CAC5B,EC9BO,IAAMG,EAAyB,CAAA,EAazBC,GAA0B,CACnC,UAAW,CACP,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,GAE5B,OAAQ,CAAE,EAAG,GAAI,EAAG,EAAE,GAGbC,GAA8B,CACvC,UAAW,CACP,CAAE,MAAO,GAAU,KAAM,EAAG,EAC5B,CAAE,MAAO,GAAU,KAAM,EAAG,EAC5B,CAAE,MAAO,GAAU,KAAM,EAAG,GAEhC,OAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,GAGXC,GAA6B,CACtC,UAAW,CACP,CAAE,MAAO,GAAS,KAAM,EAAG,EAC3B,CAAE,MAAO,GAAS,KAAM,EAAG,EAC3B,CAAE,MAAO,GAAS,KAAM,EAAG,GAE/B,OAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,GAGXC,GAAgBC,GAAkB,CAC3C,IAAMC,EAAQN,EAAQ,QAAQK,CAAM,EAChCC,GAAS,IACTN,EAAQ,OAAOM,EAAO,CAAC,CAE/B,EAEaC,GAAY,CAACC,EAAsBC,IAAqB,CACjET,EAAQ,KAAK,CACT,UAAWQ,EAAO,UAClB,cAAe,EACf,OAAQ,CACJ,MAAO,EACP,EAAGC,EAAS,EAAID,EAAO,OAAO,EAC9B,EAAGC,EAAS,EAAID,EAAO,OAAO,GAErC,CACL,EAEaE,GAAgB,IAAK,CAC9B,QAAWL,KAAUL,EAAS,CAC1B,IAAMW,EAAWC,EAAkBP,EAAO,SAAS,EACnDA,EAAO,eAAiBQ,EACpBR,EAAO,cAAgBM,EACvBP,GAAaC,CAAM,EAEnBA,EAAO,OAAO,MAAQS,GAAcT,EAAO,UAAWA,EAAO,aAAa,CAElF,CACJ,EChEA,IAAIU,GAESC,EAAW,IAAMD,GAEjBE,GAAYC,GAAiBH,GAAQG,EAErCC,GAAc,IAAK,CAC5B,IAAMJ,EAAQC,EAAQ,EAChBI,EAAOC,EAAON,EAAM,KAAK,KAAK,EAEhC,CAAEA,EAAM,OAAO,EAAI,IACnBA,EAAM,OAAO,EAAI,GAGjB,CAACA,EAAM,OAAO,EAAIK,EAAK,MAAQE,IAC/BP,EAAM,OAAO,EAAIK,EAAK,MAAQE,GAG9B,CAAEP,EAAM,OAAO,EAAI,IACnBA,EAAM,OAAO,EAAI,GAGjB,CAACA,EAAM,OAAO,EAAIK,EAAK,OAASG,IAChCR,EAAM,OAAO,EAAIK,EAAK,OAASG,EAEvC,EC3BO,IAAMC,EAAqB,CAAA,EAsDrBC,GAAWC,GAA4B,CAChD,IAAIC,EAAa,CACb,OAAAD,EACA,MAAK,EACL,WAAY,CACR,KAAM,CACF,EAAG,EACH,EAAG,GAEP,KAAM,GACN,IAAK,GACL,MAAO,IAEX,OAAQA,EAAO,OACf,UAAW,EACX,SAAU,CACN,EAAG,EACH,EAAG,GAEP,MAAO,CACH,EAAG,EACH,EAAG,GAEP,cAAe,EACf,OAAQ,CACJ,MAAO,GAEX,OAAQ,CACJ,MAAO,GAEX,OAAQ,EACR,MAAO,GAGX,OAAAF,EAAM,KAAKG,CAAI,EAERA,CACX,EAEaC,GAAcD,GAAc,CACrC,IAAME,EAAQL,EAAM,QAAQG,CAAI,EAC5BE,GAAS,IACTL,EAAM,OAAOK,EAAO,CAAC,CAE7B,EAEaC,GAAa,IAAK,CAC3BN,EAAM,OAAO,EAAGA,EAAM,MAAM,CAChC,EAEaO,GAAsB,IAAK,CACpC,IAAMC,EAAQC,EAAQ,EAEtB,QAAWN,KAAQH,EAAM,OAAM,EAC3BG,EAAK,SAAS,EAAIO,GAAMF,EAAM,OAAO,EAAGA,EAAM,OAAO,EAAIA,EAAM,OAAO,EAAGL,EAAK,SAAS,CAAC,EACxFA,EAAK,SAAS,EAAIO,GAAMF,EAAM,OAAO,EAAGA,EAAM,OAAO,EAAIA,EAAM,OAAO,EAAGL,EAAK,SAAS,CAAC,CAEhG,EAEaQ,GAAc,IAAK,CAC5B,QAAWR,KAAQH,EAAM,OAAM,EAC3BY,GAAWT,CAAI,CAEvB,EAEMS,GAAcT,GAAc,CAC9B,IAAIU,EAAmB,KAEjBX,EAASC,EAAK,OACdW,EAAaZ,EAAO,WAE1B,OAAQC,EAAK,MAAO,CAChB,IAAA,GACIU,EAAmBC,EAAW,OAE1BX,EAAK,WAAW,KAAK,GAAK,GAAKA,EAAK,WAAW,KAAK,GAAK,KACzDA,EAAK,MAAK,EACVA,EAAK,cAAgB,GAGzBY,GAAYZ,CAAI,EAChB,MAEJ,IAAA,GACQA,EAAK,WAAW,KAAK,GAAK,GAAKA,EAAK,WAAW,KAAK,GAAK,GACzDA,EAAK,MAAK,EACVA,EAAK,cAAgB,GAEhBa,GAAQb,EAAK,WAAW,KAAK,CAAC,EAAIa,GAAQb,EAAK,WAAW,KAAK,CAAC,EACrEU,EAAmBC,EAAW,MAE9BD,EAAmBC,EAAW,MAGlCG,EAAQ,UAAUd,EAAK,WAAW,IAAI,EAEtCA,EAAK,SAAS,GAAKA,EAAK,WAAW,KAAK,EAAID,EAAO,UAAYgB,EAC/Df,EAAK,SAAS,GAAKA,EAAK,WAAW,KAAK,EAAID,EAAO,UAAYgB,EAE/DH,GAAYZ,CAAI,EAChB,MAEJ,IAAA,GACIU,EAAmBC,EAAW,IAE1BK,GAAoBN,EAAkBV,EAAK,aAAa,IACpDA,EAAK,WAAW,KAChBA,EAAK,MAAK,EAEVA,EAAK,MAAK,EAEdA,EAAK,cAAgB,GAEzB,MAEJ,IAAA,GACIU,EAAmBC,EAAW,MAE1BK,GAAoBN,EAAkBV,EAAK,aAAa,IACnDA,EAAK,WAAW,OACjBA,EAAK,MAAK,EACVA,EAAK,cAAgB,IAG7B,MAEJ,IAAA,GACIU,EAAmBC,EAAW,KAE1BK,GAAoBN,EAAkBV,EAAK,aAAa,IACxDA,EAAK,MAAK,EACVA,EAAK,cAAgB,GAEzB,MAEJ,IAAA,GACIU,EAAmBV,EAAK,WAAaW,EAAW,QAE5CK,GAAoBN,EAAkBV,EAAK,aAAa,IACxDA,EAAK,MAAK,EACVA,EAAK,cAAgB,EACrBA,EAAK,UAAY,QAErB,MAEJ,IAAA,GACIU,EAAmBV,EAAK,WAAaW,EAAW,MAE/BM,EAAkBP,CAAgB,GACnCV,EAAK,cAAgBe,IACjCd,GAAWD,CAAI,EACfU,EAAmB,MAEvB,KACR,CAEAV,EAAK,SAAS,GAAKA,EAAK,MAAM,EAAIe,EAClCf,EAAK,SAAS,GAAKA,EAAK,MAAM,EAAIe,EAElCf,EAAK,MAAM,GAAK,GAChBA,EAAK,MAAM,GAAK,GAEZA,EAAK,WAAW,KAAK,EAAI,EACzBA,EAAK,UAAY,EACVA,EAAK,WAAW,KAAK,EAAI,IAChCA,EAAK,UAAY,IAGjBU,IACAV,EAAK,eAAiBe,EAEtBf,EAAK,OAAO,MAAQkB,GAAcR,EAAkBV,EAAK,aAAa,EACtEA,EAAK,OAAO,MAAQA,EAAK,UAAY,EAErCA,EAAK,OAAO,MAAQmB,GAAgBnB,EAAK,OAAO,MAAO,UAAU,EACjEA,EAAK,OAAO,MAAQA,EAAK,OAAO,OAGpCA,EAAK,OAAS,EACVA,EAAK,OAASA,EAAK,OAAO,QAC1BA,EAAK,MAAQA,EAAK,OAAO,MACzBA,EAAK,OAASD,EAAO,QAAQC,EAAK,KAAK,GAAK,EAEpD,EAEaoB,GAAmB,IAAK,CACjC,QAAWC,KAAWxB,EAAO,CAKzB,GAJIwB,EAAQ,QAAU,GAIlB,CAACA,EAAQ,OACT,SAGJ,IAAIC,EAAwB,KACxBC,EAAoBC,GACpBC,EAAoBD,GAExB,QAAWxB,KAAQH,EACf,GAAI,EAAAG,EAAK,QAAU,IAIfqB,EAAQ,OAAO,KAAOrB,EAAK,OAAO,IAAK,CACvC,IAAM0B,EAAa1B,EAAK,SAAS,EAAIqB,EAAQ,SAAS,EACtD,GAAIK,EAAaL,EAAQ,UAAY,EAAG,CACpC,IAAMM,EAAYd,GAAQa,CAAU,EAC9BE,EAAYf,GAAQQ,EAAQ,SAAS,EAAIrB,EAAK,SAAS,CAAC,EAC1D2B,EAAY,IAAMC,EAAY,KAC1B,CAACN,GAAYC,EAAoBI,GAAaF,EAAoBG,KAClEN,EAAWtB,EACXuB,EAAoBI,EACpBF,EAAoBG,EAGhC,CACJ,CAGJ,GAAIN,EAAU,CACVA,EAAS,QAAUD,EAAQ,OAE3BC,EAAS,MAAM,GAAKD,EAAQ,UAAYA,EAAQ,OAAS,IAAM,IAC/DA,EAAQ,MAAM,GAAKA,EAAQ,UAAY,GAEvC,IAAMQ,EACER,EAAQ,QAAU,GACXS,GAEHC,GAAO,EAAG,EACHC,GAEAC,GAKnBC,GAAUL,EAAQf,EAAQ,IAAIQ,EAAS,SAAU,CAAE,EAAGa,EAAY,GAAI,CAAC,EAAG,EAAGA,EAAY,IAAK,GAAG,CAAC,CAAE,CAAC,EAEjGb,EAAS,OAAS,GAClBA,EAAS,MAAK,EAEVA,EAAS,WAAaA,EAAS,OAAO,WAAW,YACjDA,EAAS,cAAgB,GAG7BA,EAAS,UAAYc,GAAa,CAC9Bd,EAAS,OAAO,WAAW,QAC3BA,EAAS,OAAO,WAAW,QAC3BA,EAAS,OAAO,WAAW,UAC9B,IAEDA,EAAS,MAAK,EACdA,EAAS,UAAYc,GAAa,CAACd,EAAS,OAAO,WAAW,MAAOA,EAAS,OAAO,WAAW,KAAK,CAAC,EACtGA,EAAS,cAAgB,EAEjC,CACJ,CACJ,EAEae,GAA6B,IAAK,CAC3C,QAAWrC,KAAQH,EAAM,OAAM,EAC3ByC,GAAyBtC,CAAI,CAErC,EAEMsC,GAA4BtC,GAAc,CAC5C,IAAMD,EAASC,EAAK,OAEpBA,EAAK,OAAO,EAAIA,EAAK,SAAS,EAAID,EAAO,OAAO,EAChDC,EAAK,OAAO,EAAIA,EAAK,SAAS,EAAID,EAAO,OAAO,EAEhD,IAAMwC,EAAQC,EAAOxC,EAAK,OAAO,KAAK,EAEtCA,EAAK,OAAO,OAAS,GACrBA,EAAK,OAAO,EAAIA,EAAK,SAAS,EAAID,EAAO,OAAO,EAAI,EACpDC,EAAK,OAAO,EAAIA,EAAK,SAAS,EAAID,EAAO,OAAO,EAAIC,EAAK,OAAO,MACpE,EAEMY,GAAeZ,GAAc,CAC3BA,EAAK,WAAW,MAChBA,EAAK,MAAK,EACVA,EAAK,cAAgB,GAGrBA,EAAK,WAAW,OAChBA,EAAK,MAAK,EACVA,EAAK,cAAgB,GAGrBA,EAAK,WAAW,QAChBA,EAAK,MAAK,EACVA,EAAK,cAAgB,EAE7B,ECnWA,IAAMyC,GAAW,IAAe,CAC5B,IAAMC,EAAkB,CAAA,EAExB,OAAAA,EAAM,EAAE,EAAI,GACZA,EAAM,EAAE,EAAI,EACZA,EAAM,EAAE,EAAI,GACZA,EAAM,EAAE,EAAI,GAEZA,EAAM,KACF,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,EAAK,EAGTA,EAAM,EAAE,EAAI,EAEZA,EAAM,KACF,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,EAAM,EAGHA,CACX,EAEMC,GAAOF,GAAQ,EAERG,GAAmBC,GAAoC,CAChE,GAAI,GAEI,KAAM,oBAAoBA,CAAI,SAAS,OAAO,aAAaA,CAAI,CAAC,GAIxE,OAAOF,GAAKE,CAAI,CACpB,ECxDO,IAAMC,EAAS,SAAS,eAAe,GAAG,EACjDA,EAAO,MAAM,eAAiB,YAE9B,IAAMC,EAAUC,EAAWF,CAAM,EAEpBG,EAAY,IACZC,EAAa,IAEpBC,EAAS,CAAE,EAAG,EAAG,EAAG,CAAC,EAEdC,GAAa,IAAK,CAC3B,IAAMC,EAAc,OAAO,WACrBC,EAAe,OAAO,YAEtBC,EAAQC,GAAQH,EAAcJ,EAAWK,EAAeJ,CAAU,EAExEJ,EAAO,MAAQW,GAAQR,EAAWI,EAAcE,CAAK,EACrDT,EAAO,OAASW,GAAQP,EAAYI,EAAeC,CAAK,EAExDT,EAAO,MAAM,MAAQ,GAAGO,CAAW,KACnCP,EAAO,MAAM,OAAS,GAAGQ,CAAY,KAErCH,EAAO,EAAIO,IAAWZ,EAAO,MAAQG,GAAa,CAAC,EACnDE,EAAO,EAAIO,IAAWZ,EAAO,OAASI,GAAc,CAAC,CACzD,EAEaS,GAAO,IAAK,CACrBZ,EAAQ,UAAU,EAAG,EAAGD,EAAO,MAAOA,EAAO,MAAM,EACnDC,EAAQ,aAAa,EAAG,EAAG,EAAG,EAAGI,EAAO,EAAGA,EAAO,CAAC,EAEnD,IAAMS,EAAQC,EAAQ,EAEtBd,EAAQ,KAAI,EACZA,EAAQ,UAAUe,EAAU,CAACF,EAAM,OAAO,CAAC,EAAGE,EAAU,CAACF,EAAM,OAAO,CAAC,CAAC,EAExEG,GAAWH,EAAM,IAAI,EAErBI,EAAM,KAAK,CAACC,EAAGC,IAAMD,EAAE,SAAS,EAAIC,EAAE,SAAS,CAAC,EAEhDnB,EAAQ,WAAa,EACrBA,EAAQ,YAAc,QACtB,QAAWoB,KAAQH,EACfD,GAAWI,EAAK,MAAM,EAE1BpB,EAAQ,WAAa,EAErB,QAAWoB,KAAQH,EACfD,GAAWI,EAAK,MAAM,EAG1B,QAAWC,KAAUC,EACjBN,GAAWK,EAAO,MAAM,EAG5BrB,EAAQ,QAAO,EAEfA,EAAQ,UAAY,QAChBD,EAAO,MAAQA,EAAO,QACtBC,EAAQ,SAAS,EAAG,CAAEI,EAAO,EAAGF,EAAWE,EAAO,CAAC,EACnDJ,EAAQ,SAAS,EAAGG,EAAYD,EAAWC,CAAU,IAErDH,EAAQ,SAAS,CAAEI,EAAO,EAAG,EAAGA,EAAO,EAAGF,CAAS,EACnDF,EAAQ,SAASE,EAAW,EAAGA,EAAWC,CAAU,GAGxDoB,GAAO,CAOX,EAEMP,GACFQ,GACA,CACAxB,EAAQ,KAAI,EAEZ,IAAMyB,EAAQC,EAAOF,EAAO,KAAK,EAE7BN,EAAI,EACJC,EAAI,EACJQ,EAAI,EACJC,EAAIJ,EAAO,QAAU,EAErBK,EAAKd,EAAUS,EAAO,GAAK,CAAC,EAC5BM,EAAKf,EAAUS,EAAO,GAAK,CAAC,EAE5BA,EAAO,QACPN,EAAI,GACJW,GAAMJ,EAAM,OAGhBzB,EAAQ,UAAUkB,EAAGC,EAAGQ,EAAGC,EAAGC,EAAIC,CAAE,EAEpCC,EAAU/B,EAASyB,EAAO,EAAG,CAAC,EAE9BzB,EAAQ,QAAO,CACnB,EAEMuB,GAAU,IAAK,CACjB,GAAI,GAAO,CACP,IAAMS,GAAaC,GAAG,EAAKC,IAAO,QAAO,EACnCC,GAAO,EAAIC,GAAQ,QAAO,EAEhCC,GACI,EAAG,EACH,OAAOF,CAAG,SAASH,CAAS,GAC5B,UAAU,CAElB,CACJ,EAEMK,GAAW,CAACC,EAAWC,EAAWC,EAAcC,IAAiB,CACnE,QAASC,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IAAK,CAClC,IAAMC,EAAOH,EAAKE,CAAC,EAAE,YAAW,EAAG,WAAW,CAAC,EACzCE,EAAKC,GAAgBF,CAAI,EAC/B,GAAIC,IAAO,OAAW,CAClB,IAAME,EAAOC,GAAgBH,EAAIH,CAAK,EAClChB,EAAQC,EAAOoB,CAAI,EACnBrB,IAAU,QACVM,EAAU/B,EAASyB,EAAOa,EAAII,EAAI,EAAGH,CAAC,CAE9C,CACJ,CACJ,ECtIA,IAAMS,GAAQ,IAAI,IAAK,CAAG,IAAI,EAAIC,EAAM,mBAAkB,EAAIC,EAAID,EAAM,aAAa,EAAE,OAAQ,EAAE,CAAC,EAAE,OAAQE,CAAK,EAAG,SAAE,IAAI,CAACC,EAAGC,IAAMH,EAAE,eAAeG,CAAC,EAAE,IAAID,CAAC,CAAC,EAAG,EAAE,OAASF,EAAG,EAAE,QAAQD,EAAM,WAAW,EAAG,EAAE,MAAK,EAAW,CAAE,EAG3NK,GAAQ,CAACC,EAAI,EAAGC,EAAI,IAAKC,EAAI,IAAKC,EAAI,EAAGC,EAAI,EAAGC,EAAI,GAAIC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGlB,EAAI,EAAGmB,EAAI,EAAGC,EAAI,EAAGC,GAAI,IAAK,CAAG,IAAIC,EAAI,EAAI,KAAK,GAAIC,GAAIZ,GAAK,IAAMW,EAAIvB,GAAS,EAAGyB,IAAK,EAAIP,EAAI,EAAI,IAAMK,EAAI,EAAGG,EAAIpB,IAAM,EAAI,EAAID,EAAI,KAAK,OAAM,EAAKA,GAAKkB,EAAIvB,EAAO2B,EAAI,CAAA,EAAIC,EAAI,EAAGC,GAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGlC,EAAI,EAAGmC,GAAGC,EAAiK,IAA9J5B,EAAI,GAAKP,EAAQO,EAAGc,GAAKrB,EAAOQ,GAAKR,EAAOS,GAAKT,EAAOC,GAAKD,EAAOa,GAAK,IAAMU,EAAIvB,GAAS,EAAGkB,GAAKK,EAAIvB,EAAOc,GAAKS,EAAIvB,EAAOe,GAAKf,EAAOgB,EAAIhB,EAAQgB,EAAI,EAAQmB,EAAI5B,EAAIc,EAAIb,EAAIC,EAAIR,EAAI,EAAG6B,EAAIK,EAAGR,EAAEG,GAAG,EAAI/B,EAAE,EAAEkC,IAAK,IAAMd,EAAI,KAAOpB,EAAIW,EAAI,EAAIA,EAAI,EAAIA,EAAI,EAAIA,EAAI,KAAK,KAAKkB,EAAIL,IAAM,CAAC,EAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAIK,CAAC,EAAG,CAAC,EAAG,EAAE,EAAI,GAAK,EAAIA,EAAIL,EAAI,EAAI,GAAK,EAAI,EAAI,EAAI,KAAK,IAAI,KAAK,MAAMK,EAAIL,CAAC,EAAIK,EAAIL,CAAC,EAAI,KAAK,IAAIK,CAAC,EAAG7B,GAAKiB,EAAI,EAAIM,GAAIA,GAAI,KAAK,IAAI,EAAI,KAAK,GAAKQ,EAAId,CAAC,EAAI,IAAM,EAAIjB,EAAI,EAAI,IAAM,KAAK,IAAIA,CAAC,GAAKY,EAAIP,EAAIgC,IAASN,EAAIvB,EAAIuB,EAAIvB,EAAIuB,EAAIvB,EAAIc,EAAI,GAAKS,EAAIvB,GAAKc,GAAK,EAAID,GAAKU,EAAIvB,EAAIc,EAAIb,EAAIY,EAAIU,EAAIK,EAAIlC,GAAKkC,EAAIL,EAAI7B,GAAKQ,EAAIW,EAAI,GAAIrB,EAAIE,EAAIF,EAAI,GAAKE,EAAI6B,EAAI,GAAKA,EAAIK,EAAIlC,EAAI,GAAKkC,EAAIL,GAAK7B,GAAK0B,EAAEG,EAAI7B,EAAI,CAAC,EAAI,GAAKF,GAAImC,IAAK5B,GAAKM,GAAKC,GAAK,KAAK,IAAIgB,GAAIX,EAAIO,EAAC,EAAGG,GAAKM,GAAIA,GAAIjB,GAAK,EAAI,KAAO,KAAK,IAAIa,CAAC,EAAI,GAAK,GAAID,IAAKK,GAAIA,GAAIjB,GAAK,EAAI,KAAO,KAAK,IAAIa,CAAC,GAAK,EAAI,GAAK,GAAIC,GAAK,EAAEA,EAAIhB,IAAMT,GAAKQ,EAAGY,GAAKZ,EAAGiB,EAAI,GAAI,CAACf,GAAK,EAAEgB,GAAIhB,IAAMV,EAAIoB,EAAGd,EAAIY,GAAGO,EAAIA,GAAK,GAAI,OAAOJ,CAAE,EAGlzCS,GAAQ,GAGRpC,EAAQ,MAGRF,EAAQ,IAAK,OAAO,cAAgB,oBAKpCuC,GAAQ,CAACC,EAAaC,EAAUC,EAAUC,EAAM,MAAO,CACzD,IAAIC,EACAxC,EACAyC,EACAtC,EACAuC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAe,EACfC,GACAC,EAAe,CAAA,EACfC,GAAoB,CAAA,EACpBC,GAAqB,CAAA,EACrBC,EAAe,EACfC,EAAU,EACVC,EAAU,EACVC,GAAc,CAAA,EACdC,EAAa,MAAQtB,EAAM,IAAM,EAGrC,KAAOoB,EAASF,IAGZH,EAAe,CAACK,EAAUd,EAAeG,EAAQE,EAAkB,CAAC,EAGpEZ,EAAS,IAAI,CAACwB,EAAcC,KAAiB,CAWzC,IATAnB,EAAiBP,EAASyB,CAAY,EAAEL,CAAY,GAAK,CAAC,EAAG,EAAG,CAAC,EAGjEE,GAAW,CAAC,CAACtB,EAASyB,CAAY,EAAEL,CAAY,EAGhDJ,GAAmBH,GAAmBb,EAASyB,CAAY,EAAE,CAAC,EAAE,OAAS,EAAI,CAACjB,GAAgBgB,EAE9FV,EAAgBY,IAAiBzB,EAAS,OAAS,EAC9CtC,EAAI,EAAGG,EAAI+C,EAAiBlD,EAAI4C,EAAe,OAASO,EAAeN,EAAe,EAAE7C,EAAG,CAU5F,IAPA0C,EAAOE,EAAe5C,CAAC,EAGvB8C,EAAO9C,GAAK4C,EAAe,OAASO,EAAgB,GAAKA,GACrDJ,IAAeH,EAAe,CAAC,GAAK,GAAKF,EAAO,EAG/CD,EAAI,EAAGA,EAAIoB,GAAchB,EAG1BJ,IAAMoB,EAAa,IAAMf,EAAOG,IAAgBA,EAAc,GAAK,GAAK,EAGxEN,GAAU,EAAIM,GAAeK,EAAaF,GAAc,EAAI,GAAK,EACjEG,GAAkBpD,CAAC,GAAKoD,GAAkBpD,CAAC,GAAK,GAAKwC,EAASe,EAAUf,EACxEa,GAAmBrD,CAAC,GAAKqD,GAAmBrD,GAAG,GAAK,GAAKwC,EAASe,EAAUf,EAI5ED,IAEAO,EAAcP,EAAO,EACrBgB,EAAUd,EAAe,CAAC,GAAK,GAC3BF,GAAQ,KAERY,EAAeM,GACX,CACIb,EAAaH,EAAeQ,EAAe,CAAC,GAAK,EACjDV,EACH,EACDkB,GAAY,CAACb,EAAYL,CAAI,CAAC,IAE9BF,EAAuB,CAAC,GAAGJ,EAAYW,CAAU,CAAC,EAElDP,EAAqB,CAAC,GAAKA,EAAqB,CAAC,GAAK,KAAQ,KAAOE,EAAO,IAAM,IAGlFA,EAAO,EAAIzC,GAAM,GAAGuC,CAAoB,EAAI,CAAA,IAI5D,CAGAU,EAAkBG,EACtB,CAAC,EAGL,MAAO,CAACE,GAAmBC,EAAkB,CACjD,EClHA,IAAMQ,GAAc,CAACC,EAAQ,KAAS,EAChCA,GAASC,EAAa,QAAU,cAClCA,EAAa,OAAM,EAAG,MAAK,CAE/B,EAEMC,GAAY,MAAOC,GAAe,CACtC,IAAMC,EAAS,MAAMC,GAAWF,CAAM,EACpCG,EAAOC,GAAM,GAAGH,CAAM,EACxBE,EAAK,KAAO,GACZL,EAAM,OAAM,CACd,EAEMI,GAAa,MAAOG,IACxB,MAAMC,GAAQ,EAAE,EACTC,GAAM,GAAGF,CAAI,GCdtB,IAAMG,GAAmC,CAAA,EAC9BC,GAAS,GAEPC,GAAY,IAAK,CAC1BC,GAAY,UAAaC,GAAK,CAC1BC,GAAW,EACXJ,GAAS,GACTD,GAAKI,EAAE,OAAO,EAAI,GAClBA,EAAE,eAAc,CACpB,EAEAD,GAAY,QAAWC,GAAK,CACxBH,GAAS,GACTK,GAAWF,EAAE,OAAO,EACpBA,EAAE,eAAc,CACpB,EAEAG,EAAO,YAAc,IAAK,CACtBF,GAAW,CACf,EAEAE,EAAO,aAAe,IAAK,CACvBF,GAAW,CACf,CACJ,EAiBaG,EAAgBC,GAAmCT,GAAKS,CAAI,EAC5DH,GAAcG,GAAc,OAAOT,GAAKS,CAAI,EC1CzD,IAAMC,GAAqB,CACvB,IAAK,GACL,OAAQ,IACR,UAAW,GACX,OAAQ,CAAE,EAAG,GAAI,EAAG,EAAE,EACtB,WAAY,CACR,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAQ,KAAM,EAAG,EAC1B,CAAE,MAAO,GAAQ,KAAM,EAAG,EAC1B,CAAE,MAAO,GAAQ,KAAM,EAAG,EAC1B,CAAE,MAAO,GAAQ,KAAM,EAAG,GAE9B,IAAK,CACD,CAAE,MAAO,GAAO,KAAM,GAAI,EAC1B,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAQ,KAAM,EAAG,EAC1B,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,KAAM,CACF,CAAE,MAAO,GAAO,KAAM,GAAI,EAC1B,CAAE,MAAO,GAAO,KAAM,GAAI,EAC1B,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,QAAS,CACL,CAAE,MAAO,GAAO,KAAM,CAAG,GAE7B,QAAS,CACL,CAAE,MAAO,GAAO,KAAM,CAAG,GAE7B,UAAW,CACP,CAAE,MAAO,GAAO,KAAM,CAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,CAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,CAAG,IAGjC,QAAS,CACJ,GAAQ,GACR,GAAS,GACT,GAAQ,KAIbC,EAESC,GAAa,IAAK,CAC3BD,EAAOE,GAAQH,EAAM,CACzB,EAEaI,EAAU,IACZH,EAGEI,GAAa,IAAK,CACtBJ,IAIDA,EAAK,QAAU,IAInBA,EAAK,WAAW,KAAK,EAAI,EACzBA,EAAK,WAAW,KAAK,EAAI,EACzBA,EAAK,WAAW,IAAM,GACtBA,EAAK,WAAW,KAAO,IAEnBK,EAAY,EAAA,GAAcA,EAAY,EAAA,KACtCL,EAAK,WAAW,KAAK,EAAI,KAGzBK,EAAY,EAAA,GAAeA,EAAY,EAAA,KACvCL,EAAK,WAAW,KAAK,EAAI,IAGzBK,EAAY,EAAA,GAAYA,EAAY,EAAA,KACpCL,EAAK,WAAW,KAAK,EAAI,KAGzBK,EAAY,EAAA,GAAcA,EAAY,EAAA,KACtCL,EAAK,WAAW,KAAK,EAAI,GAGzBK,EAAY,EAAA,IACZL,EAAK,WAAW,IAAM,IAGtBK,EAAY,EAAA,IACZL,EAAK,WAAW,KAAO,KAE/B,EChFA,IAAMM,GAAO,GAAgB,KAAK,IAAI,EAAc,EAAI,GChCxD,IAAIC,GAESC,GAA+B,CAAA,EAKvCC,IACDC,GAAS,EAGP,SAAUA,IAAS,CAChBC,KACDA,GAAe,IAAI,aAEf,GAIZ,CCnBA,eAAsBC,IAAa,CAE/B,IAAMC,EAAS,MADE,MAAM,MAAM,GAAG,GACF,YAAW,EAEnCC,EAAS,IAAI,WAAWD,CAAM,EAEhCE,EAAI,EAEFC,EAAeF,EAAOC,GAAG,EAAI,EAC7BE,EAAWH,EAAO,MAAMC,EAAGA,EAAIC,CAAY,EACjDD,GAAKC,EAEL,IAAIE,EAAeJ,EAAOC,GAAG,EAE7B,KAAOG,KAAgB,CACnB,IAAMC,EAAQL,EAAOC,GAAG,EAClBK,EAASN,EAAOC,GAAG,EAEnBM,EAAYF,EAAQC,EAEpBE,EAASR,EAAO,MAAMC,EAAGA,EAAIM,CAAS,EAC5CN,GAAKM,EAEL,IAAIE,EAAUC,GAAa,EAC3BC,GAASF,EAASJ,CAAK,EACvBO,GAAUH,EAASH,CAAM,EAEzB,IAAIO,EAAYJ,EAAQ,aAAa,EAAG,EAAGJ,EAAOC,CAAM,EAExD,QAASL,EAAI,EAAGA,EAAIO,EAAO,OAAQP,IAAK,CACpC,IAAIa,EAAIN,EAAOP,CAAC,GAAK,EAErBY,EAAU,KAAK,IAAIV,EAAS,MAAMW,EAAGA,EAAI,CAAC,EAAGb,GAAK,CAAC,CACvD,CAEAQ,EAAQ,aAAaI,EAAW,EAAG,CAAC,EAEpCE,EAAO,KAAKC,GAAUP,CAAO,CAAC,CAClC,CAEA,IAAIQ,EAAejB,EAAOC,GAAG,EAE7B,KAAOgB,KAAgB,CACnB,IAAMC,EAAYlB,EAAOC,GAAG,EAC5BkB,GAAc,KAAKpB,EAAO,MAAME,EAAGA,EAAIiB,CAAS,CAAC,EACjDjB,GAAKiB,CACT,CACJ,CCnDA,IAAAE,GAAe,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA,EAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAA,EAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA,CAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA,EAAG,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA,CAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAA,ECOv+B,IAAMC,GAAc,IAAY,CAKnC,IAAMC,EAAcC,GAAmB,IAAY,GAAW,EACxDC,EAAaC,GAAkB,IAAY,EAAU,EAErDC,EAAaC,EAAY,EACzBC,EAAcC,EAAWH,CAAU,EACzCA,EAAW,MAAQ,IACnBA,EAAW,OAAS,IACpBI,EAAUF,EAAaJ,EAAY,EAAG,CAAC,EACvCM,EAAUF,EAAaN,EAAa,EAAG,EAAU,EAEjD,IAAMS,EAAOC,GAASN,CAAU,EAE1BO,EAAU,GACVC,EAAU,EAEhB,MAAO,CACH,OAAQ,CACJ,EAAGD,EACH,EAAG,GAAaC,EAChB,EAAG,IAAaD,EAAU,EAC1B,EAAG,IAAcC,EAAU,GAE/B,KAAM,CAAE,MAAOH,CAAI,EACnB,OAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,EAE5B,EAEMR,GAAqB,CAACY,EAAeC,IAAqC,CAC5E,IAAMC,EAAQC,GAAwBH,EAAOC,EAAQ,CAAC,EAAW,EAAW,EAAW,CAAS,EAAG,CAAC,EAAG,EAAG,EAAG,CAAC,CAAC,EACzGG,EAAUV,EAAWQ,CAAK,EAE1BG,EAAS,GAEf,OAAAD,EAAQ,UAAY,QACpBA,EAAQ,SAAS,EAAG,EAAGF,EAAM,MAAO,CAAC,EAErCI,GAAcF,EAAS,EAAG,EAAGF,EAAM,MAAOG,EAAQ,WAAY,CAAC,EAC/DC,GAAcF,EAAS,EAAGF,EAAM,OAASG,EAAQH,EAAM,MAAOG,EAAQ,EAAG,UAAU,EAEnFE,GAAM,GAAIL,CAAK,EAERA,CACX,EAEMZ,GAAoB,CAACU,EAAeC,IAAqC,CAC3E,IAAMC,EAAQM,GAAkBR,EAAOC,EAAQ,CAAQ,EACjDG,EAAUV,EAAWQ,CAAK,EAE1BO,EAAU,CAAC,EAAU,EAAU,CAAQ,EACvCC,EAAiB,CAAC,EAAG,EAAG,CAAC,EAEzBC,EAAa,GAEnB,QAASC,EAAI,EAAGA,EAAIZ,EAAOY,GAAKD,EAC5B,QAASE,EAAI,EAAGA,EAAIb,EAAOa,GAAK,GAAI,CAChC,IAAMC,EAAcC,EAAOC,GAAoBP,EAASC,CAAc,CAAC,EACvEf,EAAUS,EAASU,EAAaF,EAAGC,CAAC,CACxC,CAGJI,GACI,CACI,EAAUN,EAAa,GAAI,EAC3B,EAAUA,EAAa,EAAI,GAAI,EAC/B,EAAUA,EAAa,EAAI,GAAI,EAE/B,EAAUA,EAAa,EAAI,GAAI,EAC/B,EAAUA,EAAa,EAAI,GAAI,GAEnCP,CAAO,EAGX,IAAMC,EAAS,GACf,OAAAC,GAAcF,EAAS,EAAGF,EAAM,OAASG,EAAQH,EAAM,MAAOG,EAAQ,EAAG,UAAU,EAEnFE,GAAM,GAAIL,CAAK,EAERA,CACX,EAEaK,GAAQ,CAACW,EAAgBC,IAA6B,CAC/D,IAAMf,EAAUV,EAAWyB,CAAM,EAC3BC,EAAUF,EAAS,EACnBG,EAAYjB,EAAQ,aAAa,EAAG,EAAGe,EAAO,MAAOA,EAAO,MAAM,EAClEG,EAAOD,EAAU,KACnB,EAAI,EACR,KAAO,EAAIC,EAAK,QAAQ,CACpB,IAAMC,EAAID,EAAK,CAAC,EACVE,EAAIF,EAAK,EAAI,CAAC,EACdG,EAAIH,EAAK,EAAI,CAAC,EACpBA,EAAK,CAAC,EAAIC,EAAIH,EAAUF,EAASQ,EAAU,EAC3CJ,EAAK,EAAI,CAAC,EAAIE,EAAIJ,EAAUF,EAASQ,EAAU,EAC/CJ,EAAK,EAAI,CAAC,EAAIG,EAAIL,EAAUF,EAASQ,EAAU,EAC/C,GAAK,CACT,CACAtB,EAAQ,aAAaiB,EAAW,EAAG,CAAC,CACxC,ECtGO,IAAMM,GAAQ,IAAK,CACtBC,GAASC,GAAW,CAAE,EACtBC,GAAU,EACVC,GAAU,EAEV,IAAMC,EAAQC,EAAQ,EAUhBC,EAAOC,EAAO,EACpBD,EAAK,SAAS,EAAIF,EAAM,OAAO,EAAI,GACnCE,EAAK,SAAS,EAAIF,EAAM,OAAO,EAAIA,EAAM,OAAO,EAAI,CACxD,ECpBO,IAAMI,GAAuB,IAAK,CACrC,IAAMC,EAAQC,EAAQ,EAChBC,EAAOC,EAAO,EAEpBH,EAAM,OAAO,EAAIE,EAAK,SAAS,EAAIE,EAAY,EAC/CJ,EAAM,OAAO,EAAIE,EAAK,SAAS,EAAIG,EAAa,CACpD,ECCO,IAAMC,GAAoB,CAAA,EAE3BC,GAAW,CACb,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,YAGEC,GAAqB,CACvB,IAAK,GACL,OAAQ,IACR,UAAW,GACX,OAAQ,CAAE,EAAG,GAAI,EAAG,EAAE,EACtB,WAAY,CACR,MAAO,CACH,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,GAE5B,MAAO,CACH,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,GAE5B,MAAO,CACH,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,IAAK,CACD,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,GAE5B,MAAO,CACH,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAM,KAAM,EAAG,GAE5B,KAAM,CACF,CAAE,MAAO,GAAM,KAAM,EAAG,EACxB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,QAAS,CACL,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,QAAS,CACL,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,UAAW,CACP,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,CAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,CAAG,GAE7B,MAAO,CACH,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,EAAG,EACzB,CAAE,MAAO,GAAO,KAAM,CAAG,IAGjC,QAAS,CACJ,GAAO,EACP,GAAO,GACP,GAAQ,KAIXC,GAA6B,CAAA,EAEtBC,GAAsB,IAAK,CAMpCD,GAAQ,KAAKE,GAAe,CACxB,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,YACD,KAAK,CAAC,EAETF,GAAQ,KAAKE,GAAe,CACxB,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,YACD,MAAM,CAAC,CACd,EAEMA,GAAiB,CAACC,EAA0BC,IAAoC,CAClF,IAAMC,EAAwBC,GAAYP,EAAM,EAEhDM,EAAU,UAAYE,EAAY,GAAI,EAAE,EAExC,IAAMC,EAAaH,EAAU,WAC7B,QAAWI,KAAQD,EAAY,CAC3B,IAAME,EAAYF,EAAWC,CAAI,EACjCE,GAAsBD,EAAWZ,GAAUK,EAAgBC,CAAY,CAC3E,CAEA,OAAOC,CACX,EAEMM,GAAwB,CAACD,EAAkCE,EAA+BT,EAA+BC,IAAwB,CACnJ,QAAWS,KAASH,EAChBG,EAAM,MAAQC,GAAiBD,EAAM,MAAOD,EAAgBT,EAAgBC,CAAY,CAEhG,EAEMW,GAA2C,CAAA,EAC3CD,GAAmB,CAACE,EAAYJ,EAA+BT,EAA+BC,IAAwB,CACxH,IAAMa,EAAM,GAAGD,CAAE,IAAIZ,CAAY,GACjC,GAAI,CAACW,GAAcE,CAAG,EAAG,CACrB,IAAMC,EAASC,GAAYC,EAAOJ,CAAE,CAAC,EACrCK,GAAcH,EAAQN,EAAgBT,CAAc,EACpDY,GAAcE,CAAG,EAAIK,GAASJ,CAAM,CACxC,CACA,OAAOH,GAAcE,CAAG,CAC5B,EAEaM,GAAaC,GAAuB,CAC7C,IAAMC,EAAMC,GAAQ1B,GAAQwB,CAAK,CAAC,EAClC,OAAA3B,GAAK,KAAK4B,CAAG,EACNA,CACX,EAMO,IAAME,GAAaC,GAAa,CACnC,IAAMC,EAAQC,GAAK,QAAQF,CAAG,EAC1BC,GAAS,IACTC,GAAK,OAAOD,EAAO,CAAC,CAE5B,EAEaE,GAAa,IAAK,CAC3B,IAAMC,EAAOC,EAAO,EAEpB,QAAWL,KAAOE,GACdI,GAAUN,EAAKI,CAAI,CAE3B,EAEME,GAAY,CAACN,EAAWI,IAAc,CAKxC,GAJIG,EAAM,QAAQP,CAAG,GAAK,IACtBD,GAAUC,CAAG,EAGbA,EAAI,QAAU,EACd,OAGJA,EAAI,WAAW,KAAK,EAAI,EACxBA,EAAI,WAAW,KAAK,EAAI,EACxBA,EAAI,WAAW,IAAM,GACrBA,EAAI,WAAW,KAAO,GACtBA,EAAI,WAAW,MAAQ,GAEvB,IAAMQ,EAAgB,GAEtB,GAAIR,EAAI,OAAK,GAAuBA,EAAI,OAAK,EAAoB,CAC7D,IAAMS,EAAYC,EAAQ,SAASN,EAAK,SAAUJ,EAAI,QAAQ,EAG9D,GAFiBU,EAAQ,OAAOD,CAAS,EAE1BD,EACXE,EAAQ,UAAUD,CAAS,EAC3BT,EAAI,WAAW,KAAK,EAAIS,EAAU,EAClCT,EAAI,WAAW,KAAK,EAAIS,EAAU,MAC/B,CACHT,EAAI,WAAW,KAAK,EAAI,EACxBA,EAAI,WAAW,KAAK,EAAI,EAExB,IAAMW,EAAMC,EAAU,EAClBD,EAAM,GACNX,EAAI,WAAW,KAAO,GACfW,EAAM,GACbX,EAAI,WAAW,MAAQ,GAEvBA,EAAI,WAAW,IAAM,EAE7B,CACJ,CACJ,EAEaa,GAAe,IAAK,CAC7B,GAAIX,GAAK,OAAS,EAAG,CACjB,IAAMY,EAAQC,EAAQ,EAEhBC,EAAMC,GAAO,EAAG,EAAIC,GAAU,CAAC,EAAIA,GAAU,CAAC,EACpDF,EAAI,SAAS,EAAIF,EAAM,OAAO,EAAI,IAAMK,EAAY,IAAK,EAAE,EAC3DH,EAAI,SAAS,EAAIF,EAAM,OAAO,EAAIA,EAAM,OAAO,EAAI,EAAIK,EAAY,IAAK,EAAE,CAC9E,CACJ,EChOI,GAKJ,IAAMC,GAAS,IAAK,CAChBC,GAAa,EACbC,GAAU,EAEVC,GAAU,EACVC,GAAU,EACVC,GAAW,EACXC,GAAgB,EAChBC,GAAmB,EACnBC,GAAa,EACbC,GAAY,EAEZC,GAAoB,EACpBC,GAAW,EACXC,GAA0B,EAE1BC,GAAI,EAEJ,sBAAsBb,EAAM,CAChC,EAEA,eAAec,IAAI,CACf,MAAMC,GAAa,EACnBC,GAAUC,EAAU,EACpBC,GAAS,EACTC,GAAmB,EACnBC,GAAK,EACLpB,GAAM,CACV,CAEAc,GAAI",
  "names": ["math", "mathFloor", "mathCeil", "mathRound", "mathMin", "mathMax", "mathHypot", "mathAbs", "mathRandom", "mathAtan2", "mathPI", "mathPI2", "numberMax", "limit", "min", "max", "value", "lerp", "randomRange", "chance", "randomSelect", "values", "randomChancesSelect", "chances", "total", "p", "c", "i", "domDocument", "hasTouch", "canvasName", "getContext", "canvas", "createCanvas", "domDocument", "createContext", "getCanvas", "context", "setWidth", "context", "width", "getCanvas", "setHeight", "height", "drawImage", "context", "image", "x", "y", "mathRound", "now", "cloneObject", "source", "timeout", "time", "resolve", "formatColor", "c", "a", "r", "g", "b", "createGradient", "context", "x0", "y0", "x1", "y1", "startColor", "endColor", "gradient", "generateRandomTileImage", "width", "height", "ids", "chances", "canvas", "createCanvas", "context", "getContext", "image", "images", "sx", "mathCeil", "sy", "x", "y", "randomChancesSelect", "generateTileImage", "imageId", "drawCommands", "commands", "i", "id", "drawImage", "drawGradientV", "startColor", "endColor", "createGradient", "filterImage", "canvas", "filter", "context", "getContext", "width", "height", "imageData", "pixels", "i", "pixel", "cloneCanvas", "source", "target", "createCanvas", "applyPallette", "canvas", "sourcePallette", "targetPallette", "filterImage", "pixel", "sourceColor", "pixelToColor", "index", "targetColor", "colorToPixel", "u32", "r", "g", "b", "color", "a", "images", "coloredImages", "addImage", "image", "id", "getColoredImage", "color", "key", "a", "r", "g", "b", "coloredImage", "cloneCanvas", "filterImage", "Vector2", "a", "l", "mathHypot", "b", "s", "nowMS", "now", "deltaS", "calculateTime", "oldMS", "animationDuration", "animation", "time", "frame", "getFrameImage", "animationTime", "duratuion", "i", "isAnimationFinished", "effects", "hitEffect", "hitMiniEffect", "hitRedEffect", "removeEffect", "effect", "index", "addEffect", "config", "position", "updateEffects", "duration", "animationDuration", "deltaS", "getFrameImage", "stage", "getStage", "setStage", "value", "limitCamera", "back", "images", "gameWidth", "gameHeight", "units", "addUnit", "config", "unit", "removeUnit", "index", "clearUnits", "limitUnitsPositions", "stage", "getStage", "limit", "updateUnits", "updateUnit", "currentAnimation", "animations", "checkAttack", "mathAbs", "Vector2", "deltaS", "isAnimationFinished", "animationDuration", "getFrameImage", "getColoredImage", "applyUnitsDamage", "current", "opponent", "opponentDistanceX", "numberMax", "opponentDistanceY", "directionX", "distanceX", "distanceY", "effect", "hitEffect", "chance", "hitRedEffect", "hitMiniEffect", "addEffect", "randomRange", "randomSelect", "updateUnitsSpritePositions", "updateUnitSpritePosition", "image", "images", "getChars", "chars", "font", "getIdByCharCode", "code", "canvas", "context", "getContext", "gameWidth", "gameHeight", "offset", "updateSize", "screenWidth", "screenHeight", "scale", "mathMin", "mathMax", "mathFloor", "draw", "stage", "getStage", "mathRound", "drawSprite", "units", "a", "b", "unit", "effect", "effects", "drawFPS", "sprite", "image", "images", "c", "d", "tx", "ty", "drawImage", "frameTime", "now", "nowMS", "fps", "deltaS", "drawText", "x", "y", "text", "color", "i", "code", "id", "getIdByCharCode", "char", "getColoredImage", "zzfxP", "zzfxX", "f", "zzfxR", "d", "i", "zzfxG", "q", "k", "c", "e", "t", "u", "r", "F", "v", "z", "w", "A", "l", "B", "x", "G", "y", "m", "C", "b", "H", "I", "D", "Z", "g", "E", "a", "n", "J", "K", "p", "h", "zzfxV", "zzfxM", "instruments", "patterns", "sequence", "BPM", "instrumentParameters", "j", "note", "sample", "patternChannel", "notFirstBeat", "stop", "instrument", "pitch", "attenuation", "outSampleOffset", "isSequenceEnd", "sampleOffset", "nextSampleOffset", "sampleBuffer", "leftChannelBuffer", "rightChannelBuffer", "channelIndex", "panning", "hasMore", "sampleCache", "beatLength", "patternIndex", "sequenceIndex", "unlockAudio", "force", "zzfxX", "playMusic", "source", "buffer", "renderSong", "node", "zzfxP", "song", "timeout", "zzfxM", "keys", "anyKey", "initInput", "domDocument", "e", "unlockAudio", "unpressKey", "canvas", "isKeyPressed", "code", "config", "hero", "createHero", "addUnit", "getHero", "updateHero", "isKeyPressed", "gain", "audioContext", "soundsBuffers", "hasTouch", "initSound", "audioContext", "loadResources", "buffer", "stream", "p", "palletteSize", "pallette", "imagesLength", "width", "height", "imageSize", "pixels", "context", "createContext", "setWidth", "setHeight", "imageData", "c", "images", "getCanvas", "soundsLength", "soundSize", "soundsBuffers", "background_default", "getBarStage", "floorCanvas", "generateFloorImage", "wallCanvas", "generateWallImage", "backCanvas", "createCanvas", "backContext", "getContext", "drawImage", "back", "addImage", "borderX", "borderY", "width", "height", "image", "generateRandomTileImage", "context", "border", "drawGradientV", "noise", "generateTileImage", "columns", "columnsChances", "columnStep", "x", "y", "columnImage", "images", "randomChancesSelect", "drawCommands", "offset", "canvas", "offset2", "imageData", "data", "r", "g", "b", "mathRandom", "start", "setStage", "getBarStage", "clearUnits", "createHero", "stage", "getStage", "hero", "getHero", "updateCameraPosition", "stage", "getStage", "hero", "getHero", "gameWidth", "gameHeight", "mobs", "pallette", "config", "configs", "generateMobsConfigs", "generateConfig", "targetPallette", "palletteName", "newConfig", "cloneObject", "randomRange", "animations", "name", "animation", "replaceImagesPallette", "sourcePallette", "frame", "getPalletteImage", "imagesPallete", "id", "key", "target", "cloneCanvas", "images", "applyPallette", "addImage", "createMob", "index", "mob", "addUnit", "removeMob", "mob", "index", "mobs", "updateMobs", "hero", "getHero", "updateMob", "units", "fightDistance", "direction", "Vector2", "rnd", "mathRandom", "generateMobs", "stage", "getStage", "bob", "chance", "createMob", "randomRange", "update", "calculateTime", "updateSize", "updateHero", "updateMobs", "updateUnits", "applyUnitsDamage", "limitUnitsPositions", "updateEffects", "generateMobs", "updateCameraPosition", "limitCamera", "updateUnitsSpritePositions", "draw", "main", "loadResources", "playMusic", "background_default", "initInput", "generateMobsConfigs", "start"]
}
